var documenterSearchIndex = {"docs":
[{"location":"CP/datagen/#Data-Generation","page":"Instance Generation","title":"Data Generation","text":"","category":"section"},{"location":"CP/datagen/","page":"Instance Generation","title":"Instance Generation","text":"All model generation functions use the function fill_with_generator!, which takes as input a CPModel, an AbstractModelGenerator and optionally a random number generator.","category":"page"},{"location":"CP/datagen/#Graph-Coloring","page":"Instance Generation","title":"Graph Coloring","text":"","category":"section"},{"location":"CP/datagen/","page":"Instance Generation","title":"Instance Generation","text":"SeaPearl makes available many types of graphs for the grpah coloring problem:","category":"page"},{"location":"CP/datagen/","page":"Instance Generation","title":"Instance Generation","text":"SeaPearl.fill_with_generator!\nSeaPearl.HomogenousGraphColoringGenerator\nSeaPearl.ClusterizedGraphColoringGenerator\nSeaPearl.BarabasiAlbertGraphGenerator\nSeaPearl.ErdosRenyiGraphGenerator","category":"page"},{"location":"CP/datagen/#SeaPearl.fill_with_generator!","page":"Instance Generation","title":"SeaPearl.fill_with_generator!","text":"fill_with_generator!(cpmodel::CPModel, gen::GraphColoringGenerator)\n\nFill a CPModel with the variables and constraints generated. We fill it directly instead of  creating temporary files for efficiency purpose.\n\nThis generator create clustered graphs for the graph coloring problem. It is having a fixed number of nodes and edges which is convenient to have problems of constant size. This is not compulsory (not the case  of the knapsack and of the homogeneous graph generator) but it is interesting to be sure we're working on more smooth cases.\n\nThis is done by getting a geometric distribution of each node connectivity (number of edges) and then select randomly the connexions. \n\n\n\n\n\nfill_with_generator!(cpmodel::CPModel, gen::GraphColoringGenerator)::CPModel\n\nFill a CPModel with the variables and constraints generated. We fill it directly instead of  creating temporary files for efficiency purpose ! Density should be more than 1.\n\nVery simple case from: Exploring the k-colorable Landscape with Iterated Greedy by Culberson & Luo https://pdfs.semanticscholar.org/e6cc/ab8f757203bf15680dbf456f295a7a31431a.pdf\n\n\n\n\n\nfill_with_generator!(cpmodel::CPModel, gen::GraphColoringGenerator)::CPModel\n\nFill a CPModel with the variables and constraints generated. We fill it directly instead of  creating temporary files for efficiency purpose ! Density should be more than 1.\n\nVery simple case from: Exploring the k-colorable Landscape with Iterated Greedy by Culberson & Luo https://pdfs.semanticscholar.org/e6cc/ab8f757203bf15680dbf456f295a7a31431a.pdf\n\n\n\n\n\nfill_with_generator!(cpmodel::CPModel, gen::BarabasiAlbertGraphGenerator)::CPModel\nCreates graphs according to the Barbarasi-Albert attachment model: http://networksciencebook.com/chapter/5\n\n\n\n\n\nfill_with_generator!(cpmodel::CPModel, gen::ErdosRenyiGraphGenerator)::CPModel    \n\nGenerates graphs according to the Erdos-Renyi model: https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93R%C3%A9nyi_model\n\n\n\n\n\nfill_with_generator!(cpmodel::CPModel, gen::WattsStrogatzGraphGenerator)::CPModel\n\n\n\n\n\nfill_with_generator!(cpmodel::CPModel, gen::KnapsackGenerator)::CPModel\n\nFill the cpmodel with variables and constraints for the knapsack problem. The weights are uniformly distributed between 1 and gen.max_weight, the values are uniformly distributed between (for each weight) weight - max_weight/(10*correlation) and weight + max_weight/(10*correlation). It is possible to give Inf as the gen.correlation to have a strict equality between the weights and their values. gen.correlation must be strictly positive. This method is from the following paper: https://www.researchgate.net/publication/2548374CoreProblemsinKnapsack_Algorithms\n\nRng is a random number generator used to ensure experiment reproductibility accross devices. It is often set at the beginning of an experiment to generate deterministic training samples. \n\n\n\n\n\nfill_with_generator!(cpmodel::CPModel, gen::TsptwGenerator)::CPModel\n\nFill a CPModel with the variables and constraints generated. We fill it directly instead of  creating temporary files for efficiency purpose !\n\nIt is the same generator as used in  \"Combining Reinforcement Learning and Constraint Programming for Combinatorial Optimization\": Quentin Cappart, Thierry Moisan, Louis-Martin Rousseau, Isabeau PrÃ©mont-Schwarz & Andre Cire https://arxiv.org/abs/2006.01610\n\nBasicaly finds positions with a uniform distributions, then sets the time windows by creating a feasible tour and adding some randomness by using uniform distributions with gap and the length of the time windows.\n\nRng is a random number generator used to ensure experiment reproductibility accross devices. It is often set at the beginning of an experiment to generate deterministic training samples. \n\n\n\n\n\nfill_with_generator!(cpmodel::CPModel, gen::GraphColoringGenerator)\n\nFill a CPModel with the variables and constraints generated. We fill it directly instead of creating temporary files for efficiency purpose.\n\nRng is a random number generator used to ensure experiment reproductibility accross devices. It is often set at the beginning of an experiment to generate deterministic training samples. \n\nThis generator create graps for the NQueens problem.\n\n\n\n\n\nfill_with_generator!(cpmodel::CPModel, gen::GraphColoringGenerator)\n\nFill a CPModel with the variables and constraints generated. We fill it directly instead of creating temporary files for efficiency purpose.\n\nThis generator create graphs for the Eternity2 problem.\n\n\n\n\n\nfill_with_generator!(cpmodel::CPModel, gen::GraphColoringGenerator)\n\nFill a CPModel with the variables and constraints generated. We fill it directly instead of creating temporary files for efficiency purpose.\n\nRng is a random number generator used to ensure experiment reproductibility accross devices. It is often set at the beginning of an experiment to generate deterministic training samples. \n\n\n\n\n\nfill_with_generator!(cpmodel::CPModel, gen::RBGenerator)\n\nFill a CPModel with the variables and constraints generated. We fill it directly instead of  creating temporary files for efficiency purpose !\n\nThis is the algorithm proposed by \"Random constraint satisfaction: Easy generation of  hard (satisfiable) instances\" (Xu. et al, 2007) to generate forced satisfiable instance of RB.\n\n\n\n\n\nfill_with_generator!(cpmodel::CPModel, gen::KepGenerator; rng::AbstractRNG = MersenneTwister())\n\nFill a CPModel with the variables and constraints generated. We fill it directly instead of  creating temporary files for efficiency purpose!\n\nThe decision matrix x is the adjacent matrix of the graph (i.e. the instance).  x[i, j] is branchable => pair i can receive a kidney from pair j x[i, j] is not branchable => pair i can not receive a kidney from pair j\n\nThe generator ensure that all pairs have at least one incoming arc and one outgoing arc (i.e. at least one branchable variable per row and column). For this we first place one branchable variable in each line of the matrix with a different column index each time. Then, the remaining edges are assigned randomly between the non-asssigned elements of the decision matrix. For reference, see https://hal.science/hal-01798850/document\n\n\n\n\n\nfill_with_generator!(cpmodel::CPModel, gen::JobShopGenerator)\n\nFill a CPModel with the variables and constraints generated. We fill it directly instead of  creating temporary files for efficiency purpose. \n\n\n\n\n\nfill_with_generator!(cpmodel::CPModel, gen::JobShopSoftDeadlinesGenerator)\n\nFill a CPModel with the variables and constraints generated. We fill it directly instead of  creating temporary files for efficiency purpose. Generates jobshop with soft deadlines instances.\n\n\n\n\n\nfill_with_generator!(cpmodel::CPModel, gen::GraphColoringGenerator)\n\nFill a CPModel with the variables and constraints generated. We fill it directly instead of  creating temporary files for efficiency purpose.\n\n\n\n\n\n","category":"function"},{"location":"CP/datagen/#SeaPearl.ClusterizedGraphColoringGenerator","page":"Instance Generation","title":"SeaPearl.ClusterizedGraphColoringGenerator","text":"struct ClusterizedGraphColoringGenerator <: AbstractModelGenerator\n\nGenerator of Graph Coloring instances : \n- n is the number of nodes\n- k is the number of color\n- p is the edge density of the graph\n\n\n\n\n\n","category":"type"},{"location":"CP/datagen/#SeaPearl.BarabasiAlbertGraphGenerator","page":"Instance Generation","title":"SeaPearl.BarabasiAlbertGraphGenerator","text":"struct BarabasiAlbertGraphGenerator <: AbstractModelGenerator\n\nGenerator of Graph Coloring instances : \n- n is the number of nodes\n- k is the number of color\nhttp://networksciencebook.com/chapter/5\n\n\n\n\n\n","category":"type"},{"location":"CP/datagen/#SeaPearl.ErdosRenyiGraphGenerator","page":"Instance Generation","title":"SeaPearl.ErdosRenyiGraphGenerator","text":"struct ErdosRenyiGraphGenerator <: AbstractModelGenerator\n\nGenerator of Graph Coloring instances : \n- n is the number of nodes\n- k is the number of color\n\nhttps://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93R%C3%A9nyi_model\n\n\n\n\n\n","category":"type"},{"location":"CP/datagen/#Eternity-2","page":"Instance Generation","title":"Eternity 2","text":"","category":"section"},{"location":"CP/datagen/","page":"Instance Generation","title":"Instance Generation","text":"SeaPearl.Eternity2Generator","category":"page"},{"location":"CP/datagen/#Jobshop","page":"Instance Generation","title":"Jobshop","text":"","category":"section"},{"location":"CP/datagen/","page":"Instance Generation","title":"Instance Generation","text":"SeaPearl.JobShopGenerator\nSeaPearl.JobShopSoftDeadlinesGenerator2","category":"page"},{"location":"CP/datagen/#SeaPearl.JobShopGenerator","page":"Instance Generation","title":"SeaPearl.JobShopGenerator","text":"JobShopGenerator  <: AbstractModelGenerator Generator for standard jobshop problem with:     - numberOfMachines::Int : Number of available machines     - numberOfJobs::Int : Number of jobs to accomplish     - maxTime::Int : Maximum available\n\nhttps://en.wikipedia.org/wiki/Job-shop_scheduling\n\n\n\n\n\n","category":"type"},{"location":"CP/datagen/#Kidney-Exchange","page":"Instance Generation","title":"Kidney Exchange","text":"","category":"section"},{"location":"CP/datagen/","page":"Instance Generation","title":"Instance Generation","text":"SeaPearl.KepGenerator","category":"page"},{"location":"CP/datagen/#SeaPearl.KepGenerator","page":"Instance Generation","title":"SeaPearl.KepGenerator","text":"KepGenerator <: AbstractModelGenerator Generator for the kidney exchange problem: https://hal.science/hal-01798850/document\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#Reinforcement-Learning","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"","category":"section"},{"location":"reinforcement_learning/#Neural-Networks","page":"Reinforcement Learning","title":"Neural Networks","text":"","category":"section"},{"location":"reinforcement_learning/","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"SeaPearl.CPNN\nSeaPearl.FullFeaturedCPNN\nSeaPearl.HeterogeneousCPNN\nSeaPearl.HeterogeneousFullFeaturedCPNN\nSeaPearl.HeterogeneousVariableOutputCPNN\nSeaPearl.VariableOutputCPNN","category":"page"},{"location":"reinforcement_learning/#SeaPearl.CPNN","page":"Reinforcement Learning","title":"SeaPearl.CPNN","text":"CPNN(;\n    graphChain::Flux.Chain = Flux.Chain()\n    nodeChain::Flux.Chain = Flux.Chain()\n    globalChain::Flux.Chain = Flux.Chain()\n    outputChain::Union{Flux.Dense, Flux.Chain} = Flux.Chain()\n)\n\nThis structure is here to provide a flexible way to create a nn model which respect this approach: Making modification on the graph, then extract one node feature and modify it. The CPNN pipeline uses the features of the variable branched on (variableFeatures)  and, if specified, the global features of the graph (globalFeatures). Contrary to FullFeaturedCPNN, it does not use the features of the possible values to make predictions. This pipeline is made of 4 networks:\n\ngraphChain: a graph convolutional network (GCN). It takes the original featured graph (states.fg) as an input,\nnodeChain: a fully connected neural network (FCNN). It takes the features of the variable to branch on as an input,\nglobalChain: FCNN. It takes the global features of the graph as an input,\noutputChain: FCNN. It takes the concatenation of the outputs of nodeChain and globalChain as an input.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.FullFeaturedCPNN","page":"Reinforcement Learning","title":"SeaPearl.FullFeaturedCPNN","text":"FullFeaturedCPNN(;\n    graphChain::Flux.Chain\n    nodeChain::Flux.Chain\n    globalChain::Flux.Chain\n    outputChain::Flux.Dense\n)\n\nThis structure is here to provide a flexible way to create a nn model which respect this approach: Making modification on the graph, then extract one node feature and modify it.\n\nThis pipeline is made of 4 networks:\n\ngraphChain: a graph convolutional network (GCN). It takes the original featured graph (states.fg) as an input,\nnodeChain: a fully connected neural network (FCNN). It is used both on variableFeatures and valueFeatures.\nglobalChain: FCNN. It takes the global features of the graph as an input,\noutputChain: FCNN. It takes the concatenation of the outputs of nodeChain and globalChain as an input.\n\nLike the CPNN pipeline, the FullFeaturedCPNN pipeline uses the features (variableFeatures) of the variable branched on  and, if specified, the global features of the graph (globalFeatures). But contrary to CPNN, it also uses the features (valueFeatures) of the possible values that the variable can be assigned to.\n\nFullFeaturedCPNN generates a Q-table containing the Q-value of all the values, both the possible and impossible ones.  A mask then selects the possible values.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.HeterogeneousCPNN","page":"Reinforcement Learning","title":"SeaPearl.HeterogeneousCPNN","text":"HeterogeneousCPNN(;\n    graphChain::Flux.Chain = Flux.Chain()\n    nodeChain::Flux.Chain = Flux.Chain()\n    globalChain::Flux.Chain = Flux.Chain()\n    outputChain::Union{Flux.Dense, Flux.Chain} = Flux.Chain()\n)\n\nThis structure is here to provide a flexible way to create a nn model which respect this approach: Making modification on the graph, then extract one node feature and modify it.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.HeterogeneousFullFeaturedCPNN","page":"Reinforcement Learning","title":"SeaPearl.HeterogeneousFullFeaturedCPNN","text":"HeterogeneousFullFeaturedCPNN(;\n    graphChain::Flux.Chain\n    varChain::Flux.Chain = Flux.Chain()\n    valChain::Flux.Chain = Flux.Chain()\n    globalChain::Flux.Chain\n    outputChain::Flux.Dense\n)\n\nThis structure is here to provide a flexible way to create a nn model which respect this approach: Making modification on the graph, then extract one node feature and modify it. This CPNN is designed to process HeterogeneousFeaturedGraphs.\n\nThis pipeline works in the following way : \n\nWe apply a GNN on the input featured graph.\nWe extract the contextualized-feature of the branching variable and pass it trought varChain\nWe extract the contextualized-feature of each value that is part of the variable's domain of definition and pass it trought valChain.\nWe concat the two reshaped previous results (optionnaly with a global feature) and pass it trought outputChain to generate the output Q-vector.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.HeterogeneousVariableOutputCPNN","page":"Reinforcement Learning","title":"SeaPearl.HeterogeneousVariableOutputCPNN","text":"HeterogeneousVariableOutputCPNN(;\n    graphChain::Flux.Chain\n    nodeChain::Flux.Chain\n    outputChain::Flux.Dense\n)\n\nThis structure is here to provide a flexible way to create a nn model which respect this approach: Making modification on the graph, then extract one node feature and modify it. \n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.VariableOutputCPNN","page":"Reinforcement Learning","title":"SeaPearl.VariableOutputCPNN","text":"VariableOutputCPNN(;\n    graphChain::Flux.Chain\n    nodeChain::Flux.Chain\n    outputChain::Flux.Dense\n)\n\nThis structure is here to provide a flexible way to create a nn model which respect this approach: Making modification on the graph, then extract one node feature and modify it. \n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#State-Representation","page":"Reinforcement Learning","title":"State Representation","text":"","category":"section"},{"location":"reinforcement_learning/","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"SeaPearl.DefaultStateRepresentation\nSeaPearl.DefaultTrajectoryState\nSeaPearl.BatchedDefaultTrajectoryState\nSeaPearl.HeterogeneousStateRepresentation\nSeaPearl.HeterogeneousTrajectoryState\nSeaPearl.GraphColoringStateRepresentation\nSeaPearl.MISStateRepresentation\nSeaPearl.TsptwFeaturization\nSeaPearl.TsptwStateRepresentation\nSeaPearl.AbstractTrajectoryState\nSeaPearl.TabularTrajectoryState\nSeaPearl.NonTabularTrajectoryState\nSeaPearl.AbstractStateRepresentation\nSeaPearl.AbstractFeaturization\nSeaPearl.FeaturizedStateRepresentation\nSeaPearl.trajectoryState\nSeaPearl.featurize\n","category":"page"},{"location":"reinforcement_learning/#SeaPearl.DefaultStateRepresentation","page":"Reinforcement Learning","title":"SeaPearl.DefaultStateRepresentation","text":"DefaultStateRepresentation{F, TS}\n\nThis is the default representation used by SeaPearl unless the user define his own.\n\nIt consists in a tripartite graph representation of the CP Model, with features associated with each node and an index specifying the variable that should be branched on.\n\nFields:\n\ncplayergraph: representation of the problem as a tripartite graph.\nnodeFeatures: Feature matrix of the nodes. Each column corresponds to a node.\nglobalFeatures: Feature vector of the entire graph.\nvariableIdx: Index of the variable we are currently considering.\nallValuesIdx: Index of value nodes in cplayergraph.\nvalueToPos: Dictionary mapping the value of an action to its position in the one-hot encoding of the value. \n\nThe boolean corresponds to the fact that the feature is used or not, the integer corresponds to the position of the feature in the vector.\n\nchosenFeatures: Dictionary of featurization options. The boolean corresponds to whether the feature is active or not, \n\nthe integer corresponds to the position of the feature in the vector. See below for details about the options.\n\nconstraintTypeToId: Dictionary mapping the type of a constraint to its position in the one-hot encoding of the constraint type.\n\nThe chosenFeatures dictionary specify a boolean -notifying whether the features are active or not -  and a position for the following features:\n\n\"constraint_activity\": whether or not the constraint is active for constraint nodes\n\"constraint_type\": a one-hot encoding of the constraint type for constraint nodes\n\"nbinvolvedconstraint_propagation\": the number of times the constraint has been put in the fixPoint call stack for constraint nodes.\n\"nbnotbounded_variable\": the number of non-bound variable involve in the constraint for constraint nodes\n\"variabledomainsize\": the current size of the domain of the variable for variable nodes \n\"variableinitialdomain_size\": the initial size of the domain of the variable for variable nodes\n\"variableisbound\": whether or not the variable is bound for variable nodes\n\"values_onehot\": a one-hot encoding of the value for value nodes\n\"values_raw\": the raw value of the value for value nodes\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.DefaultTrajectoryState","page":"Reinforcement Learning","title":"SeaPearl.DefaultTrajectoryState","text":"DefaultTrajectoryState\n\nThe most basic state representation, with a featured graph, the index of the variable to branch on and optionnaly a list of possible values.\n\nfg::FeaturedGraph                                   Associated tri-partite graph containing features on each node.\nvariableIdx::Int                                    Index of the node in the feature graph that represents the choosen variable. \nallValuesIdx::Union{Nothing, AbstractVector{Int}}   Indexes of the nodes in the feature graph that reprensents values\npossibleValuesIdx::Union{Nothing, Vector{Int64}}    Indexes of the nodes in the feature graph that reprensents values in the domain of definition of the variable.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.BatchedDefaultTrajectoryState","page":"Reinforcement Learning","title":"SeaPearl.BatchedDefaultTrajectoryState","text":"BatchedDefaultTrajectoryState\n\nThe batched version of the DefaultTrajectoryState.\n\nIt contains all the information that would be stored in a FeaturedGraph but reorganised to enable simultaneous  computation on a few graphs.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.HeterogeneousStateRepresentation","page":"Reinforcement Learning","title":"SeaPearl.HeterogeneousStateRepresentation","text":"HeterogeneousStateRepresentation{F, TS}\n\nSimilar to the DefaultStateRepresentation, except that the feature matrices are specific to each type of node (constraint, variable and value).\n\nIt consists in a tripartite graph representation of the CP Model, with features associated with each node and an index specifying the variable that should be branched on.\n\nFields:\n\ncplayergraph: representation of the problem as a tripartite graph.\nconstraintNodeFeatures: Feature matrix of the constraint nodes. Each column corresponds to a node.\nvariableNodeFeatures: Feature matrix of the variable nodes. Each column corresponds to a node.\nvalueNodeFeatures: Feature matrix of the value nodes. Each column corresponds to a node.\nglobalFeatures: Feature vector of the entire graph.\nvariableIdx: Index of the variable we are currently considering.\nallValuesIdx: Index of value nodes in cplayergraph.\nvalueToPos: Dictionary mapping the value of an action to its position in the one-hot encoding of the value. \n\nThe boolean corresponds to the fact that the feature is used or not, the integer corresponds to the position of the feature in the vector.\n\nchosenFeatures: Dictionary of featurization options. The boolean corresponds to whether the feature is active or not, \n\nthe integer corresponds to the position of the feature in the vector. See below for details about the options.\n\nconstraintTypeToId: Dictionary mapping the type of a constraint to its position in the one-hot encoding of the constraint type.\n\nThe chosenFeatures dictionary specify a boolean -notifying whether the features are active or not -  and a position for the following features:\n\n\"constraint_activity\": whether or not the constraint is active for constraint nodes\n\"constraint_type\": a one-hot encoding of the constraint type for constraint nodes\n\"nbinvolvedconstraint_propagation\": the number of times the constraint has been put in the fixPoint call stack for constraint nodes.\n\"nbnotbounded_variable\": the number of non-bound variable involve in the constraint for constraint nodes\n\"variabledomainsize\": the current size of the domain of the variable for variable nodes \n\"variableinitialdomain_size\": the initial size of the domain of the variable for variable nodes\n\"variableisbound\": whether or not the variable is bound for variable nodes\n\"values_onehot\": a one-hot encoding of the value for value nodes\n\"values_raw\": the raw value of the value for value nodes\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.HeterogeneousTrajectoryState","page":"Reinforcement Learning","title":"SeaPearl.HeterogeneousTrajectoryState","text":"HeterogeneousTrajectoryState\n\nThe most basic state representation, with a featured graph, the index of the variable to branch on and optionnaly a list of possible values.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.GraphColoringStateRepresentation","page":"Reinforcement Learning","title":"SeaPearl.GraphColoringStateRepresentation","text":"GraphColoringStateRepresentation{F, TS}\n\nThis is a standard graphcoloring representation using the graph of the problem with nodes having their assigned value as label.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.MISStateRepresentation","page":"Reinforcement Learning","title":"SeaPearl.MISStateRepresentation","text":"MISStateRepresentation{F, TS}\n\nThis is a standard MIS representation using the graph of the problem with nodes having their assigned value as label.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.TsptwStateRepresentation","page":"Reinforcement Learning","title":"SeaPearl.TsptwStateRepresentation","text":"TsptwStateRepresentation{F, TS}\n\nThis is the Tsptw representation used by Quentin Cappart in Combining Reinforcement Learning and Constraint Programming for Combinatorial Optimization (https://arxiv.org/pdf/2006.01610.pdf).\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.AbstractTrajectoryState","page":"Reinforcement Learning","title":"SeaPearl.AbstractTrajectoryState","text":"AbstractTrajectoryState\n\nThe TrajectoryState is a component of the AbstractStateRepresentation specifying how to store this representation in the trajectory of the RL agent for learning.\n\nIt might be necessary to implement your own when defining a new state representation or when another data formatting is necessary for learning. To implement a subtype of AbstractTrajectoryState one must provide:\n\na struct subtype of TabularTrajectoryState or NonTabularTrajectoryState depending on you usage.\na constructor with signature YourTrajectoryState(sr::YourStateRepresentation).\na function Flux.functor(::Type{YourTrajectoryState}, ts) (see Flux.functor for further information).\nan NN model taking a YourTrajectoryState instance as an input.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.TabularTrajectoryState","page":"Reinforcement Learning","title":"SeaPearl.TabularTrajectoryState","text":"TabularTrajectoryState\n\nAbstract subtype of AbstractTrajectoryState for array based representations of state.\n\nThis type isn't currently used, but it will certainly be a lot clearer if one can easily distinguish between array based representations, and more exotic ones (e.g. graphs, named tuples...).\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.NonTabularTrajectoryState","page":"Reinforcement Learning","title":"SeaPearl.NonTabularTrajectoryState","text":"NonTabularTrajectoryState\n\nAbstract subtype of AbstractTrajectoryState for non array based representations of state.\n\nThis type is th only one currently used, but it will certainly be a lot clearer if one can easily distinguish between array based representations, and more exotic ones (e.g. graphs, named tuples...).\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.AbstractStateRepresentation","page":"Reinforcement Learning","title":"SeaPearl.AbstractStateRepresentation","text":"AbstractStateRepresentation{TS}\n\nThe AbstractStateRepresentation is the abstract type of the structures representing the internal state of the CPModel and eventually the state of the search in a way that will be as expressive as possible.\n\nIt requires a specific AbstractTrajectoryState to make the bridge between the internal state representation and one the RL agent can use to decide of the value to be assigned when branching.\n\nA user can use the DefaultStateRepresentation with the DefaultTrajectoryState provided by the package but he has the possibility to define his own.\n\nTo define a new one, the user must provide:\n\na new structure, subtype of AbstractStateRepresentation with the appropriate subtype of AbstractTrajectoryState and all its dependencies.\na constructor from a CPModel, with keyword argument action_space.\na function update_representation!(::AbstractStateRepresentation, ::CPModel, ::AbstractIntVar) to update the state representation at each step.\n\nLook at the DefaultStateRepresentation to get inspired.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.AbstractFeaturization","page":"Reinforcement Learning","title":"SeaPearl.AbstractFeaturization","text":"AbstractFeaturization\n\nEvery subtype of FeaturizedStateRepresentation{F} requires an AbstractFeaturization.\n\nThis type gives the possibility to characterise these feature based representations, and thus gives the ability to easily define new ones. To implement your own featurization, one must provide:\n\na struct subtype of AbstractFeaturization (no field is used by the DefaultStateRepresentation).\na function featurize(::FeaturizedStateRepresentation{YourFeaturization, TS}) where TS returning a feature Matrix with features stored columnwise.\na function feature_length(::Type{<:FeaturizedStateRepresentation{YourFeaturization, TS} where TS} returning the size of a feature vector.\noptionally a function update_features!(::FeaturizedStateRepresentation{YourFeaturization, TS}, ::CPModel) where TS to update your feature vectors based on statistics gathered by the CP Model.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.FeaturizedStateRepresentation","page":"Reinforcement Learning","title":"SeaPearl.FeaturizedStateRepresentation","text":"FeaturizedStateRepresentation{F, TS}\n\nAbstract subtype of AbstractStateRepresentation specializing the type of features used in the representation.\n\nWhen a user wants to try a new featurization with the same organisation of the featurized elements, instead of having to completely redefine a new type of AbstractStateRepresentation, he can keep the same and just use a new AbstractFeaturization.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.trajectoryState","page":"Reinforcement Learning","title":"SeaPearl.trajectoryState","text":"trajectoryState(sr::AbstractStateRepresentation{TS})\n\nReturn a TrajectoryState based on the present state represented by sr.\n\nThe type of the returned object is defined by the TS parametric type defined in sr.\n\n\n\n\n\n","category":"function"},{"location":"reinforcement_learning/#SeaPearl.featurize","page":"Reinforcement Learning","title":"SeaPearl.featurize","text":"featurize(sr::DefaultStateRepresentation{DefaultFeaturization, TS})\n\nCreate features for every node of the graph. Can be overwritten for a completely custom featurization.\n\nDefault behavior consists in a 3D One-hot vector that encodes whether the node represents a Constraint, a Variable or a Value.\n\nIt is also possible to pass a chosen_features dictionary allowing to choose among some non mandatory features.  It will be used in initChosenFeatures! to initialize sr.chosenFeatures.  See DefaultStateRepresentation for a list of possible options. It is only necessary to specify the options you wish to activate.\n\n\n\n\n\nfeaturize(sr::HeterogeneousStateRepresentation{DefaultFeaturization, TS})\n\nCreate features for every node of the graph. Can be overwritten for a completely custom featurization.\n\nDefault behavior consists in a 3D One-hot vector that encodes whether the node represents a Constraint, a Variable or a Value.\n\nIt is also possible to pass a chosen_features dictionary allowing to choose among some non mandatory features.  It will be used in initChosenFeatures! to initialize sr.chosenFeatures.  See HeterogeneousStateRepresentation for a list of possible options. It is only necessary to specify the options you wish to activate.\n\n\n\n\n\nfunction featurize(sr::TsptwStateRepresentation{TsptwFeaturization})\n\nCreate nodeFeatures for every node of the graph. Supposed to be overwritten.  Tsptw behavior is to call Tsptw_featurize.\n\n\n\n\n\nfunction featurize(sr::GraphColoringStateRepresentation{GraphColoringFeaturization})\n\nCreate nodeFeatures for every node of the graph (current color of the node or -1 if the color has not been determined yet)\n\n\n\n\n\nfunction featurize(sr::MISStateRepresentation{MISFeaturization})\n\nCreate nodeFeatures for every node of the graph (current color of the node or -1 if the color has not been determined yet)\n\n\n\n\n\n","category":"function"},{"location":"CP/trailer/#Trailer:-backtrack-easily-and-efficiently","page":"Trailer","title":"Trailer: backtrack easily and efficiently","text":"","category":"section"},{"location":"CP/trailer/","page":"Trailer","title":"Trailer","text":"The trailer is the object that keeps track of anything you want to keep track of. Some objects will take a trailer as a parameter in their constructor. When it does, it means that their state can be saved and restored on demand using the functions described below.","category":"page"},{"location":"CP/trailer/#State-manipulation","page":"Trailer","title":"State manipulation","text":"","category":"section"},{"location":"CP/trailer/","page":"Trailer","title":"Trailer","text":"Those functions are used to change the current state, save and or restore it.","category":"page"},{"location":"CP/trailer/","page":"Trailer","title":"Trailer","text":"Note that during your \"state exploration\", you can only restore higher. It is not possible to restore some deeper state, or state that could be in the same level. For example, if you have a state A at some point, you call SeaPearl.saveState! to store it. You edit some SeaPearl.StateObject, making you at some state B. Then you call SeaPearl.restoreState! that will restore every SeaPearl.StateObject to the state A. At that point, there is no way to go back to the state B using the trailer.","category":"page"},{"location":"CP/trailer/","page":"Trailer","title":"Trailer","text":"SeaPearl.StateObject\r\nSeaPearl.StateEntry\r\nSeaPearl.trail!\r\nSeaPearl.setValue!\r\nSeaPearl.saveState!\r\nSeaPearl.restoreState!\r\nSeaPearl.withNewState!\r\nSeaPearl.restoreInitialState!","category":"page"},{"location":"CP/trailer/#SeaPearl.StateObject","page":"Trailer","title":"SeaPearl.StateObject","text":"StateObject{T}(value::T, trailer::Trailer)\n\nA reversible object of value value that has a type T, storing its modification into trailer.\n\n\n\n\n\n","category":"type"},{"location":"CP/trailer/#SeaPearl.StateEntry","page":"Trailer","title":"SeaPearl.StateEntry","text":"StateEntry{T}(value::T, object::StateObject{T})\n\nAn entry that can be stacked in the trailer, containing the former value of the object, and a reference to theobject` so that it can be restored by the trailer.\n\n\n\n\n\n","category":"type"},{"location":"CP/trailer/#SeaPearl.trail!","page":"Trailer","title":"SeaPearl.trail!","text":"trail!(var::StateObject{T})\n\nStore the current value of var into its trailer.\n\n\n\n\n\n","category":"function"},{"location":"CP/trailer/#SeaPearl.setValue!","page":"Trailer","title":"SeaPearl.setValue!","text":"setValue!(var::StateObject{T}, value::T) where {T}\n\nChange the value of var, replacing it with value, and if needed, store the former value into var's trailer.\n\n\n\n\n\n","category":"function"},{"location":"CP/trailer/#SeaPearl.saveState!","page":"Trailer","title":"SeaPearl.saveState!","text":"saveState!(trailer::Trailer)\n\nStore the current state into the trailer, replacing the current stack with an empty one.\n\n\n\n\n\n","category":"function"},{"location":"CP/trailer/#SeaPearl.restoreState!","page":"Trailer","title":"SeaPearl.restoreState!","text":"restoreState!(trailer::Trailer)\n\nIterate over the last state to restore every former value, used to backtrack every change  made after the last call to saveState!.\n\n\n\n\n\n","category":"function"},{"location":"CP/trailer/#SeaPearl.withNewState!","page":"Trailer","title":"SeaPearl.withNewState!","text":"withNewState!(func, trailer::Trailer)\n\nCall the func function with a new state, restoring it after. Aimed to be used with the do block syntax.\n\nExamples\n\nusing SeaPearl\ntrailer = SeaPearl.Trailer()\nreversibleInt = SeaPearl.StateObject{Int}(3, trailer)\nSeaPearl.withNewState!(trailer) do\n    SeaPearl.setValue!(reversibleInt, 5)\nend\nreversibleInt.value # 3\n\n\n\n\n\n","category":"function"},{"location":"CP/trailer/#SeaPearl.restoreInitialState!","page":"Trailer","title":"SeaPearl.restoreInitialState!","text":"restoreInitialState!(trailer::Trailer)\n\nRestore every linked object to its initial state. Basically call restoreState! until not possible.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#Variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"CP/variables/#Integer-variables","page":"Variables","title":"Integer variables","text":"","category":"section"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"The implementation of integer variables in SeaPearl is heavily inspired on MiniCP. If you have some troubles understanding how it works, you can get more visual explanations by reading their slides.","category":"page"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"The integer variables are all a subset of AbstractIntVar.","category":"page"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"Every AbstractIntVar must have a unique id that you can retrieve with id.","category":"page"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"SeaPearl.id\nSeaPearl.isbound\nSeaPearl.assign!(::SeaPearl.AbstractIntVar, ::Int)\nSeaPearl.assignedValue","category":"page"},{"location":"CP/variables/#SeaPearl.id","page":"Variables","title":"SeaPearl.id","text":"function id(x::AbstractVar)\n\nReturn the string identifier of x. Every variable must be assigned a unique identifier upon creation, that will be used as a key to identify the variable in the CPModel object.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#SeaPearl.isbound","page":"Variables","title":"SeaPearl.isbound","text":"isbound(x::AbstractIntVar)\n\nCheck whether x has an assigned value.\n\n\n\n\n\nisbound(x::AbstractBoolVar)\n\nCheck whether x has an assigned value.\n\n\n\n\n\nisbound(x::IntSetVar)\n\nCheck whether x has an assigned value (meaning its domain only contains one subset)\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#SeaPearl.assign!-Tuple{SeaPearl.AbstractIntVar, Int64}","page":"Variables","title":"SeaPearl.assign!","text":"assign!(x::AbstractIntVar, value::Int)\n\nRemove everything from the domain of x but value.\n\n\n\n\n\n","category":"method"},{"location":"CP/variables/#SeaPearl.assignedValue","page":"Variables","title":"SeaPearl.assignedValue","text":"assignedValue(x::AbstractIntVar)\n\nReturn the assigned value of x. Throw an error if x is not bound.\n\n\n\n\n\nassignedValue(x::BoolVar)\n\nReturn the assigned value of x. Throw an error if x is not bound.\n\n\n\n\n\nassignedValue(x::IntSetVar)\n\nReturn the assigned value of x, i.e. the only subset it contains. Throw an error if x is not bound.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#IntVar","page":"Variables","title":"IntVar","text":"","category":"section"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"SeaPearl.IntVar\nSeaPearl.IntVar(::Int, ::Int, ::String, ::SeaPearl.Trailer)","category":"page"},{"location":"CP/variables/#SeaPearl.IntVar","page":"Variables","title":"SeaPearl.IntVar","text":"struct IntVar <: AbstractIntVar\n\nA \"simple\" integer variable, whose domain can be any set of integers. The constraints that affect this variable are stored in the onDomainChange array.\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#SeaPearl.IntVar-Tuple{Int64, Int64, String, SeaPearl.Trailer}","page":"Variables","title":"SeaPearl.IntVar","text":"function IntVar(min::Int, max::Int, id::String, trailer::Trailer)\n\nCreate an IntVar with a domain being the integer range [min, max] with the id string identifier and that will be backtracked by trailer.\n\n\n\n\n\n","category":"method"},{"location":"CP/variables/#IntDomain","page":"Variables","title":"IntDomain","text":"","category":"section"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"SeaPearl.AbstractIntDomain\nSeaPearl.IntDomain\nSeaPearl.IntDomain(::SeaPearl.Trailer, ::Int, ::Int)","category":"page"},{"location":"CP/variables/#SeaPearl.AbstractIntDomain","page":"Variables","title":"SeaPearl.AbstractIntDomain","text":"abstract type AbstractIntDomain end\n\nAbstract domain type. Every integer domain must inherit from this type.\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#SeaPearl.IntDomain","page":"Variables","title":"SeaPearl.IntDomain","text":"struct IntDomain <: AbstractIntDomain\n\nSparse integer domain. Can contain any set of integer.\n\nYou must note that this implementation takes as much space as the size of the initial domain. However, it can be pretty efficient in accessing and editing. Operation costs are detailed for each method.\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#SeaPearl.IntDomain-Tuple{SeaPearl.Trailer, Int64, Int64}","page":"Variables","title":"SeaPearl.IntDomain","text":"IntDomain(trailer::Trailer, n::Int, offset::Int)\n\nCreate an integer domain going from ofs + 1 to ofs + n. Will be backtracked by the given trailer.\n\n\n\n\n\n","category":"method"},{"location":"CP/variables/#Domain-updates","page":"Variables","title":"Domain updates","text":"","category":"section"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"SeaPearl.isempty\nSeaPearl.length\nSeaPearl.isempty\nBase.in(::Int, ::SeaPearl.IntDomain)\nSeaPearl.remove!\nSeaPearl.removeAll!\nSeaPearl.removeAbove!\nSeaPearl.removeBelow!\nSeaPearl.assign!\nBase.iterate(::SeaPearl.IntDomain)\nSeaPearl.updateMaxFromRemovedVal!\nSeaPearl.updateMinFromRemovedVal!\nSeaPearl.updateBoundsFromRemovedVal!\nSeaPearl.minimum\nSeaPearl.maximum","category":"page"},{"location":"CP/variables/#Base.length","page":"Variables","title":"Base.length","text":"length(dom::IntDomain)\n\nReturn the size of dom. Done in constant time.\n\n\n\n\n\nlength(dom::BoolDomain)\n\nReturn the size of dom. Done in constant time.\n\n\n\n\n\nlength(dom::IntDomainView)\n\nReturn the size of dom.\n\n\n\n\n\nlength(dom::BoolDomainView)\n\nReturn the size of dom.\n\n\n\n\n\nlength(dom::IntDomain)\n\nReturn the size of dom. Done in constant time.\n\n\n\n\n\nBase.length(set::SetModification)\n\na generic function length is needed for all modifications. \n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#Base.in-Tuple{Int64, SeaPearl.IntDomain}","page":"Variables","title":"Base.in","text":"Base.in(value::Int, dom::IntDomain)\n\nCheck if an integer is in the domain. Done in constant time.\n\n\n\n\n\n","category":"method"},{"location":"CP/variables/#SeaPearl.remove!","page":"Variables","title":"SeaPearl.remove!","text":"remove!(dom::IntDomain, value::Int)\n\nRemove value from dom. Done in constant time.\n\n\n\n\n\nremove!(dom::BoolDomain, value::Bool)\n\nRemove value from dom. Done in constant time.\n\n\n\n\n\nremove!(dom::BoolDomain, value::Int)\n\nRemove value from dom. Done in constant time.\n\n\n\n\n\nremove!(dom::IntDomainView, value::Int)\n\nRemove value from dom.\n\n\n\n\n\nremove!(dom::BoolDomainViewNot, value::Bool)\n\nRemove value from dom.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#SeaPearl.removeAll!","page":"Variables","title":"SeaPearl.removeAll!","text":"removeAll!(dom::IntDomain)\n\nRemove every value from dom. Return the removed values. Done in constant time.\n\n\n\n\n\nremoveAll!(dom::BoolDomain)\n\nRemove every value from dom. Return the removed values. Done in constant time.\n\n\n\n\n\nremoveAll!(dom::IntDomainView)\n\nRemove every value from dom. Return the removed values.\n\n\n\n\n\nremoveAll!(dom::BoolDomainViewNot)\n\nRemove every value from dom. Return the removed values.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#SeaPearl.removeAbove!","page":"Variables","title":"SeaPearl.removeAbove!","text":"removeAbove!(dom::IntDomain, value::Int)\n\nRemove every integer of dom that is strictly above value. Done in linear time.\n\n\n\n\n\nremoveAbove!(dom::IntDomain, value::Int)\n\nRemove every integer of dom that is strictly above value. Done in linear time.\n\n\n\n\n\nremoveAbove!(dom::IntDomainView, value::Int)\n\nRemove every integer of dom that is strictly above value.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#SeaPearl.removeBelow!","page":"Variables","title":"SeaPearl.removeBelow!","text":"removeBelow!(dom::IntDomain, value::Int)\n\nRemove every integer of dom that is strictly below value. Return the pruned values. Done in linear time.\n\n\n\n\n\nremoveBelow!(dom::IntDomain, value::Int)\n\nRemove every integer of dom that is strictly below value. Return the pruned values. Done in linear time.\n\n\n\n\n\nremoveBelow!(dom::IntDomainView, value::Int)\n\nRemove every integer of dom that is strictly below value. Return the pruned values.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#SeaPearl.assign!","page":"Variables","title":"SeaPearl.assign!","text":"assign!(dom::IntDomain, value::Int)\n\nRemove everything from the domain but value. Return the removed values. Return the pruned values. Done in constant time.\n\n\n\n\n\nassign!(x::AbstractIntVar, value::Int)\n\nRemove everything from the domain of x but value.\n\n\n\n\n\nassign!(dom::BoolDomain, value::Bool)\n\nRemove everything from the domain but value. Return the removed values. Return the pruned values. Done in constant time.\n\n\n\n\n\nassign!(dom::BoolDomain, value::Int)\n\nRemove everything from the domain but value. Return the removed values. Return the pruned values. Done in constant time.\n\n\n\n\n\nassign!(x::BoolVar, value::Bool)\n\nRemove everything from the domain of x but value.\n\n\n\n\n\nassign!(dom::IntDomainView, value::Int)\n\nRemove everything from the domain but value. Return the removed values. Return the pruned values.\n\n\n\n\n\nassign!(dom::BoolDomainViewNot, value::Bool)\n\nRemove everything from the domain but value. Return the removed values. Return the pruned values.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#Base.iterate-Tuple{SeaPearl.IntDomain}","page":"Variables","title":"Base.iterate","text":"Base.iterate(dom::IntDomain, state=1)\n\nIterate over the domain in an efficient way. The order may not be consistent. WARNING: Do NOT update the domain you are iterating on.\n\n\n\n\n\n","category":"method"},{"location":"CP/variables/#SeaPearl.updateMaxFromRemovedVal!","page":"Variables","title":"SeaPearl.updateMaxFromRemovedVal!","text":"updateMaxFromRemovedVal!(dom::IntDomain, v::Int)\n\nKnowing that v just got removed from dom, update dom's maximum value. Done in constant time.\n\n\n\n\n\nupdateMaxFromRemovedVal!(dom::IntDomainView, v::Int)\n\nKnowing that v just got removed from dom, update dom's maximum value.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#SeaPearl.updateMinFromRemovedVal!","page":"Variables","title":"SeaPearl.updateMinFromRemovedVal!","text":"updateMinFromRemovedVal!(dom::IntDomain, v::Int)\n\nKnowing that v just got removed from dom, update dom's minimum value. Done in constant time.\n\n\n\n\n\nupdateMinFromRemovedVal!(dom::IntDomainView, v::Int)\n\nKnowing that v just got removed from dom, update dom's minimum value.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#SeaPearl.updateBoundsFromRemovedVal!","page":"Variables","title":"SeaPearl.updateBoundsFromRemovedVal!","text":"updateBoundsFromRemovedVal!(dom::AbstractIntDomain, v::Int)\n\nKnowing that v just got removed from dom, update dom's minimum and maximum value. Done in constant time.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#SeaPearl.minimum","page":"Variables","title":"SeaPearl.minimum","text":"minimum(dom::IntDomain)\n\nReturn the minimum value of dom. Done in constant time.\n\n\n\n\n\nminimum(dom::BoolDomain)\n\nReturn the minimum value of dom. Done in constant time.\n\n\n\n\n\nminimum(dom::IntDomainView)\n\nReturn the minimum value of dom.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#SeaPearl.maximum","page":"Variables","title":"SeaPearl.maximum","text":"maximum(dom::IntDomain)\n\nReturn the maximum value of dom. Done in constant time.\n\n\n\n\n\nmaximum(dom::BoolDomain)\n\nReturn the maximum value of dom. Done in constant time.\n\n\n\n\n\nmaximum(dom::IntDomainView)\n\nReturn the maximum value of dom.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"If you want to express some variations of an integer variable x (for example -x or a x with a  0) in a constraint, you can use the IntVarView types:","category":"page"},{"location":"CP/variables/#IntVarView","page":"Variables","title":"IntVarView","text":"","category":"section"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"SeaPearl.IntVarViewMul\nSeaPearl.IntVarViewOpposite\nSeaPearl.IntVarViewOffset","category":"page"},{"location":"CP/variables/#SeaPearl.IntVarViewMul","page":"Variables","title":"SeaPearl.IntVarViewMul","text":"IntVarViewMul(x::AbstractIntVar, a::Int, id::String)\n\nCreate a fake variable y, such that y == a*x. This variable behaves like an usual one.\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#SeaPearl.IntVarViewOpposite","page":"Variables","title":"SeaPearl.IntVarViewOpposite","text":"IntVarViewOpposite(x::AbstractIntVar, id::String)\n\nCreate a *fake* variable `y`, such that `y = -x`. This variable behaves like an usual one.\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#IntDomainView","page":"Variables","title":"IntDomainView","text":"","category":"section"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"SeaPearl.IntDomainViewMul\nSeaPearl.IntDomainViewOpposite\nSeaPearl.IntDomainViewOffset","category":"page"},{"location":"CP/variables/#SeaPearl.IntDomainViewMul","page":"Variables","title":"SeaPearl.IntDomainViewMul","text":"IntDomainViewMul(orig::AbstractIntDomain, a::Int)\n\nDomain for an integer variable that is a multiple of another integer variable. See IntVarViewMul.\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#SeaPearl.IntDomainViewOpposite","page":"Variables","title":"SeaPearl.IntDomainViewOpposite","text":"IntDomainViewOpposite(orig::AbstractIntDomain)\n\nDomain for an integer variable that is the opposite of another integer variable (y = -x).\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#SeaPearl.IntDomainViewOffset","page":"Variables","title":"SeaPearl.IntDomainViewOffset","text":"IntDomainViewOffset(orig::AbstractIntDomain, c::Int)\n\nDomain for an integer variable that is offset by a constant 'c' (y = x + c)\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#Boolean-Variables","page":"Variables","title":"Boolean Variables","text":"","category":"section"},{"location":"CP/variables/#Base-Boolean-Variables","page":"Variables","title":"Base Boolean Variables","text":"","category":"section"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"SeaPearl.BoolVar","category":"page"},{"location":"CP/variables/#SeaPearl.BoolVar","page":"Variables","title":"SeaPearl.BoolVar","text":"struct BoolVar <: AbstractVar\n\nA \"simple\" boolean variable. The constraints that affect this variable are stored in the onDomainChange array.\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#Boolean-View-Variables","page":"Variables","title":"Boolean View Variables","text":"","category":"section"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"SeaPearl.BoolVarViewNot","category":"page"},{"location":"CP/variables/#SeaPearl.BoolVarViewNot","page":"Variables","title":"SeaPearl.BoolVarViewNot","text":"BoolVarViewNot(x::AbstractBoolVar, id::String)\n\nFake variable y, such that y = Â¬x. This variable behaves like an usual one.\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#Boolean-Domains","page":"Variables","title":"Boolean Domains","text":"","category":"section"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"SeaPearl.BoolDomain\nSeaPearl.BoolDomainViewNot","category":"page"},{"location":"CP/variables/#SeaPearl.BoolDomain","page":"Variables","title":"SeaPearl.BoolDomain","text":"struct BoolDomain <: AbstractDomain\n\nBoolean domain, uses a IntDomain in it. (true is 1 and false is 0)\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#SeaPearl.BoolDomainViewNot","page":"Variables","title":"SeaPearl.BoolDomainViewNot","text":"BoolDomainViewNot <: BoolDomainView Domain for BoolVarView variables\n\n\n\n\n\n","category":"type"},{"location":"CP/internals/#SeaPearl-Internals","page":"Internals","title":"SeaPearl Internals","text":"","category":"section"},{"location":"CP/internals/#CPModel","page":"Internals","title":"CPModel","text":"","category":"section"},{"location":"CP/internals/","page":"Internals","title":"Internals","text":"SeaPearl.Statistics\nSeaPearl.Limit\nSeaPearl.CPModel\nSeaPearl.addVariable!\nSeaPearl.addObjective!\nSeaPearl.addKnownObjective!\nSeaPearl.addConstraint!\nSeaPearl.is_branchable\nSeaPearl.branchable_variables\nSeaPearl.solutionFound\nSeaPearl.triggerFoundSolution!\nSeaPearl.triggerInfeasible!\nSeaPearl.tightenObjective!\nBase.isempty\nBase.empty!\nSeaPearl.reset_model!\nSeaPearl.restart_search!\nSeaPearl.domains_cartesian_product\nSeaPearl.nb_boundvariables\nSeaPearl.global_domain_cardinality\nSeaPearl.updateStatistics!","category":"page"},{"location":"CP/internals/#SeaPearl.Statistics","page":"Internals","title":"SeaPearl.Statistics","text":"Statistics Contains statistics used in the search process:\n\ninfeasibleStatusPerVariable::Dict{String,Int} : maps variable id to the number of infeasible solutions the variable was involved in\nnumberOfNodes::Int : number of nodes in the search\nnumberOfSolutions::Int : number of solutions found\nnumberOfInfeasibleSolutions::Int : number of infeasible solutions found\nnumberOfSolutionsBeforeRestart::Int : number of solutions found before the search restart\nnumberOfInfeasibleSolutionsBeforeRestart::Int : number of infeasible solutions found before the search restart\nnumberOfNodesBeforeRestart::Int : number of nodes in the search tree before the search restart\nAccumulatedRewardBeforeReset::Float32 : reward accumulated before the search reset\nAccumulatedRewardBeforeRestart::Float32 : reward accumulated before the search restart\nsolutions::Vector{Union{Nothing,Solution}} : solutions found\nnodevisitedpersolution::Vector{Int} : number of times nodes that were visited in solutions\nobjectives::Union{Nothing,Vector{Union{Nothing,Int}}}\nlastPruning::Union{Nothing,Int} \nobjectiveDownPruning::Union{Nothing,Float32}\nobjectiveUpPruning::Union{Nothing,Float32}\nlastVar::Union{Nothing,AbstractIntVar} : Last variable that the search branched on\nnumberOfTimesInvolvedInPropagation::Union{Nothing,Dict{Constraint,Int}} : number of times every constraint was involved in a propagation\n\n\n\n\n\n","category":"type"},{"location":"CP/internals/#SeaPearl.Limit","page":"Internals","title":"SeaPearl.Limit","text":"Limit(numberOfNodes::Union{Int, Nothing}, numberOfSolutions::Union{Int, Nothing}, searchingTime::Union{Int, Nothing}) Limits for the search process.\n\n\n\n\n\n","category":"type"},{"location":"CP/internals/#SeaPearl.CPModel","page":"Internals","title":"SeaPearl.CPModel","text":"CPModel(trailer::Trailer)\nCPModel()\n\nThe structure storing all the information needed when solving a given problem, as well as the solutions that were found. The CPModel is at the core of the solving process and evolves over its course. Note: The AbstractStateRepresentation used by the RL Agent is created from the CPModel.\n\nThe CPModel is always created empty and is filled eather by hand by the user (or automatically thanks to written files) or filled by an AbstractModelGenerator.\n\nThe CPModel struct has the following attributes:     - variables::Dict{String,AbstractVar} : dict mapping variable id to variables     - branchable::Dict{String,Bool} : dict mapping variable id to a bool indicating whether or not the variables are branchable     - branchable_variables::Dict{String, AbstractVar} : dict where the keys are the variable id's of ONLY the branchable variables. Maps variable id's to variables     - constraints::Array{Constraint} : Array of all the model's constraints     - trailer::Trailer : trailer used for the search and solving     - objective::Union{Nothing,AbstractIntVar} : objective function of the model     - objectiveBound::Union{Nothing,Int}     - statistics::Statistics : statistics, described in details     - limit::Limit : model's limits     - knownObjective::Union{Nothing,Int64} : optional; contains the known objective of the model. For example, if the goal is to minimize the number of delays, it could be set to 0.     - adhocInfo::Any : Any ad-hoc information related to the CPModel\n\n\n\n\n\n","category":"type"},{"location":"CP/internals/#SeaPearl.addVariable!","page":"Internals","title":"SeaPearl.addVariable!","text":"addVariable!(model::CPModel, x::AbstractVar; branchable=true)\n\nAdd a variable to the model, throwing an error if x's id is already in the model. The branchable argument allows you to tell if we will be able to branch on that variable.\n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#SeaPearl.addObjective!","page":"Internals","title":"SeaPearl.addObjective!","text":"addObjective!(model::CPModel, objective::AbstractVar)\n\nAdd an Objective variable to the model. This variable is the variable that needs to be minimized suring the solving.\n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#SeaPearl.addKnownObjective!","page":"Internals","title":"SeaPearl.addKnownObjective!","text":"addKnownObjective!(model::CPModel, knownObective::Int64)\n\nAdd a known Objective to the model. \n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#SeaPearl.addConstraint!","page":"Internals","title":"SeaPearl.addConstraint!","text":"addConstraint!(model::CPModel, constraint::Constraint)\n\nAdd a constraint to the CPModel.\n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#SeaPearl.is_branchable","page":"Internals","title":"SeaPearl.is_branchable","text":"function is_branchable(model::CPModel, x::AbstractVar)\n\nTell if the variable was set as branchable or not.\n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#SeaPearl.branchable_variables","page":"Internals","title":"SeaPearl.branchable_variables","text":"function branchable_variables(model::CPModel)\n\nReturn a dict of all branchable variables, mapping from variable id to variable.\n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#SeaPearl.solutionFound","page":"Internals","title":"SeaPearl.solutionFound","text":"solutionFound(model::CPModel)\n\nReturn a boolean, checking whether a solution was found, i.e. every variable is bound.\n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#SeaPearl.triggerFoundSolution!","page":"Internals","title":"SeaPearl.triggerFoundSolution!","text":"triggerFoundSolution!(model::CPModel)\n\nAdd the current solution to model, and set new constraints for the objective if needed.\n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#SeaPearl.triggerInfeasible!","page":"Internals","title":"SeaPearl.triggerInfeasible!","text":"triggerInfeasible!(constraint::Constraint, model::CPModel)\n\nThis function increments by one the statistic infeasibleStatusPerVariable for each variable involved in the constraint. infeasibleStatusPerVariable keeps track for each variable the number of times the variable was involved in a constraint that led to an infeasible state during a fixpoint. This statistic is used by the failure-based variable selection heuristic.\n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#SeaPearl.tightenObjective!","page":"Internals","title":"SeaPearl.tightenObjective!","text":"tightenObjective!(model::CPModel)\n\nSet a new constraint to minimize the objective variable.\n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#Base.isempty","page":"Internals","title":"Base.isempty","text":"isempty(dom::IntDomain)\n\nReturn true iff dom is an empty set. Done in constant time.\n\n\n\n\n\nisempty(dom::BoolDomain)\n\nReturn true iff dom is an empty set. Done in constant time.\n\n\n\n\n\nisempty(dom::IntDomainView)\n\nReturn true iff dom is an empty set.\n\n\n\n\n\nisempty(dom::BoolDomainView)\n\nReturn true iff dom is an empty set.\n\n\n\n\n\nBase.isempty(model::CPModel)::Bool\n\nReturn a boolean describing if the model is empty or not.\n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#Base.empty!","page":"Internals","title":"Base.empty!","text":"Base.empty!(model::CPModel)\n\nEmpty the CPModel.\n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#SeaPearl.reset_model!","page":"Internals","title":"SeaPearl.reset_model!","text":"reset_model!(model::CPModel)\n\nReset a given CPModel instance. Make it possible to reuse the same instance instead of having to delete the old one and create another one. This is used in launch_experiment! in order to be able to use the same CPModel instance to compare different given heuristics.\n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#SeaPearl.restart_search!","page":"Internals","title":"SeaPearl.restart_search!","text":"restart_search!(model::CPModel)\n\nRestarts the search process. Useful when dealing with restart based search : ILDS or RBS. Resets to zero are useful statistics on the search that can be used to define the restart criteria.\n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#SeaPearl.domains_cartesian_product","page":"Internals","title":"SeaPearl.domains_cartesian_product","text":"domains_cartesian_product(model::CPModel)\n\nReturn the cartesian product of the model variables: |D1|x|D2|x ... x|Dn| Helps providing insights about what is happening during a search.\n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#SeaPearl.nb_boundvariables","page":"Internals","title":"SeaPearl.nb_boundvariables","text":"nb_boundvariables(model::CPModel)\n\nReturn the number of variables that have already been assigned to a value (that are bound). Helps providing insights about what is happening during a search.\n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#SeaPearl.global_domain_cardinality","page":"Internals","title":"SeaPearl.global_domain_cardinality","text":"global_domain_cardinality(model::CPModel)\n\nReturns the sum of the cardinalities of all the variable domains.\n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#SeaPearl.updateStatistics!","page":"Internals","title":"SeaPearl.updateStatistics!","text":"updateStatistics!(model::CPModel, pruned)\n\nCalled in DFS to update the appropriate statistics used in GeneralReward\n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#Search","page":"Internals","title":"Search","text":"","category":"section"},{"location":"CP/internals/","page":"Internals","title":"Internals","text":"SeaPearl.search!\nSeaPearl.initroot!\nSeaPearl.expandDfs!\nSeaPearl.expandDfwbs!\nSeaPearl.expandIlds!\nSeaPearl.expandLns!\nSeaPearl.expandRbs!","category":"page"},{"location":"CP/internals/#SeaPearl.search!","page":"Internals","title":"SeaPearl.search!","text":"search!(model::CPModel, strategy::S, variableHeuristic::AbstractVariableSelection, valueSelection::ValueSelection=BasicHeuristic(); out_solver::Bool=false) where S <: SearchStrategy Perform a search following a specific strategy in the model using variableHeuristic to choose which domain will be changed at each branching and using valueSelection to choose how the branching will be done. \n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#SeaPearl.initroot!","page":"Internals","title":"SeaPearl.initroot!","text":"initroot!(toCall::Stack{Function}, ::DFSearch, model::CPModel, variableHeuristic::AbstractVariableSelection, valueSelection::ValueSelection)\n\nUsed as a generic function to instantiate the research based on a specific Strategy <: SearchStrategy. \n\n\n\n\n\ninitroot!(toCall::Stack{Function}, ::DFWBSearch, model::CPModel, variableHeuristic::AbstractVariableSelection, valueSelection::ValueSelection)\n\nUsed as a generic function to instantiate the research based on a specific Strategy <: SearchStrategy. \n\n\n\n\n\ninitroot!(toCall::Stack{Function}, ::ILDSearch, model::CPModel, variableHeuristic::AbstractVariableSelection, valueSelection::ValueSelection)\n\ngeneric function to instantiate the research based on a specific Strategy <: SearchStrategy. The max discrepancy correspond to the number of branchable variables  at the beginning of the search. Calls to expandIlds! with a decreasing discrepancy is stacked in the toCall Stack. \n\n\n\n\n\n    function initroot!(toCall::Stack{Function}, strategy::S, model::CPModel, variableHeuristic::AbstractVariableSelection, valueSelection::ValueSelection) where {S <: RBSearch}\n\nIt fills the toCall Stack in a certains order based on a specific Strategy <: RBSearch with  function that expand the search tree. In restart based strategy, we fill the Stack with calls to expandRbs with different nodeLimit. The nodeLimit corresponds  to the number of infeasiblesolution that can be reached before restarting the search a the top of the tree with a possibly different nodeLimit. This search  strategy requires the use of a stochastic variable/value heuristic, otherwise, at each restart the search will end-up on the exact previous solutions.\n\n\n\n\n\ninitroot!(toCall::Stack{Function}, search::LNSearch, model::CPModel, variableHeuristic::AbstractVariableSelection, valueSelection::ValueSelection)\n\nUsed as a generic function to instantiate the research based on a specific Strategy <: SearchStrategy. \n\n# Arguments\n\ntoCall: In this search strategy, toCall is not used (an empty stack will be returned)\nsearch: Object containing the parameters of the search strategy\nmodel: CPModel to be solved\nvariableHeuristic: Variable selection method to be used in the search\nvalueSelection: Value selection method to be used in the search\n\n\n\n\n\ninitroot!(toCall::Stack{Function}, ::F, model::CPModel, variableHeuristic::AbstractVariableSelection, valueSelection::ValueSelection) where F <: SearchStrategy\n\nInitialisation function that fill the toCall Stack according to a certain strategy. \n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#SeaPearl.expandDfs!","page":"Internals","title":"SeaPearl.expandDfs!","text":"expandDfs!(toCall::Stack{Function}, model::CPModel, variableHeuristic::Function, valueSelection::ValueSelection, newConstraints=nothing)\n\nAdd procedures to toCall, that, called in the stack order (LIFO) with the model parameter, will perform a DFS in the graph. Some procedures will contain a call to expandDfs! itself. Each expandDfs! call is wrapped around a saveState! and a restoreState! to be able to backtrack thanks to the trailer.\n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#SeaPearl.expandDfwbs!","page":"Internals","title":"SeaPearl.expandDfwbs!","text":"expandDfs!(toCall::Stack{Function}, model::CPModel, variableHeuristic::Function, valueSelection::ValueSelection, newConstraints=nothing)\n\nAdd procedures to toCall, that, called in the stack order (LIFO) with the model parameter, will perform a DFS in the graph. Some procedures will contain a call to expandDfs! itself. Each expandDfs! call is wrapped around a saveState! and a restoreState! to be able to backtrack thanks to the trailer.\n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#SeaPearl.expandIlds!","page":"Internals","title":"SeaPearl.expandIlds!","text":"expandIlds!(toCall::Stack{Function}, discrepancy::Int64, previousdepth::Int64, direction::Union{Nothing, Symbol} , model::CPModel, variableHeuristic::AbstractVariableSelection, valueSelection::ValueSelection, newConstraints=nothing)\n\nThis function fills the toCall Stack (LIFO) and perform a recursive Limited Discrepancy Search. Some procedures will contain a call to expandIlds! itself. Each expandIlds!  call is wrapped around a saveState! and a restoreState! to be able to backtrack thanks to the trailer. \n\nThis implementation is based on this paper : Limited Discrepancy Search - 1995 - William  D.  Harvey  and  Matthew  L.  Ginsberg. This method is not efficiant compared to the Korf approach but doesn't need any given max depth of the search  tree, which is unknown for CP search tree.   We should maybe look at this : https://www.researchgate.net/publication/220639800Limiteddiscrepancysearchrevisited\n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#SeaPearl.expandLns!","page":"Internals","title":"SeaPearl.expandLns!","text":"expandLns!(search::LNSearch, model::CPModel, variableHeuristic::AbstractVariableSelection, valueSelection::ValueSelection)\n\nThis function make a Large Neighbourhood Search. As initial solution we use the first feasible solution found by a DFS.  Then a destroy and repair loop tries to upgrade the current solution until some stop critiria.\n\n# Arguments\n\nsearch: Object containing the parameters of the search strategy\nmodel: CPModel to be solved\nvariableHeuristic: Variable selection method to be used in the search\nvalueSelection: Value selection method to be used in the search\n\n\n\n\n\n","category":"function"},{"location":"CP/internals/#SeaPearl.expandRbs!","page":"Internals","title":"SeaPearl.expandRbs!","text":"expandRbs!(toCall::Stack{Function}, model::CPModel, variableHeuristic::Function, valueSelection::ValueSelection, newConstraints=nothing)\n\nAdd procedures to toCall, that, called in the stack order (LIFO) with the model parameter, will perform a RBS in the graph. Some procedures will contain a call to expandRbs! itself. Each expandRbs! call is wrapped around a saveState! and a restoreState! to be able to backtrack thanks to the trailer. \n\nThe Search stops as long as the search reached the limit on a given criteria. .\n\n\n\n\n\n","category":"function"},{"location":"CP/search/#Search-strategies","page":"Search","title":"Search strategies","text":"","category":"section"},{"location":"CP/search/","page":"Search","title":"Search","text":"SeaPearl.DFS\nSeaPearl.DFWBS\nSeaPearl.LNSearch\nSeaPearl.ILDSearch\nSeaPearl.RBSearch\nSeaPearl.staticRBSearch\nSeaPearl.geometricRBSearch\nSeaPearl.lubyRBSearch","category":"page"},{"location":"CP/search/#SeaPearl.LNSearch","page":"Search","title":"SeaPearl.LNSearch","text":"struct LNSearch <: SearchStrategy Implementation of Large Neighboorhood Search  This implementation is inspired on this paper: Using Constraint Programming and Local Search Methods to Solve Vehicle Routing Problems (April 1998, Paul Shaw) The number of values to remove in each destroy and repair loop is initialised to 1 and increase by 1 after limitIterNoImprovement iterations  with no improvement until limitValuesToRemove is reached. limitValuesToRemove will be set to half of the branching variables by default. With `repairLimits' one can fix limits (numberOfNodes, numberOfSolutions, searchingTime) that will be applied to the model used in the local search. Example: SeaPearl.solve!(model, SeaPearl.LNSearch(limitValuesToRemove=5, repairSearch=SeaPearl.ILDS(1), repairLimits=Dict(\"searchingTime\" => 10)); ...)\n\n\n\n\n\n","category":"type"},{"location":"CP/search/#SeaPearl.ILDSearch","page":"Search","title":"SeaPearl.ILDSearch","text":"struct ILDSearch <: SearchStrategy\n\nimplements the basic version of the Iterative Limited Discrepancy Search, ddue to the fact that the depth of the search tree is unknow before the search we cannot use the improved version of the Iterate Limited Discrepancy Search by Richard E. Korf. d is the max-discrepancy. \n\n\n\n\n\n","category":"type"},{"location":"CP/search/#SeaPearl.staticRBSearch","page":"Search","title":"SeaPearl.staticRBSearch","text":"struct staticRBSearch <: RBSearch\n\nimplements the static Restart-Based strategy where the stopping criteria L remains the same at each restart. \n\n\n\n\n\n","category":"type"},{"location":"CP/search/#SeaPearl.geometricRBSearch","page":"Search","title":"SeaPearl.geometricRBSearch","text":"struct geometricRBSearch <: RBSearch\n\nimplements the geometric Restart-Based strategy where the stopping criteria L is increased by the geometric factor Î± at each restart. \n\n\n\n\n\n","category":"type"},{"location":"CP/search/#SeaPearl.lubyRBSearch","page":"Search","title":"SeaPearl.lubyRBSearch","text":"struct lubyRBSearch <: RBSearch\n\nimplements the Luby Restart-Based strategy where the stopping criteria L is multiplied by the factor Luby[i] for the i-th restart.  The Luby sequence is a sequence of the following form: 1,1,2,1,1,2,4,1,1,2,1,1,2,4,8, . .and gives theoretical improvement on the search in the general case.\n\n\n\n\n\n","category":"type"},{"location":"community/#Community","page":"Community","title":"Community","text":"","category":"section"},{"location":"community/","page":"Community","title":"Community","text":"Everyone is welcome to contribute to this project, by opening issues or PR on the Github repository. Please have a look at our (contributions guideline)[https://github.com/corail-research/SeaPearl.jl/blob/master/CONTRIBUTING.md].","category":"page"},{"location":"CP/performance_test/#Performance-test-Gecode-vs-SeaPearl","page":"Performance test - Gecode vs SeaPearl","title":"Performance test - Gecode vs SeaPearl","text":"","category":"section"},{"location":"CP/performance_test/","page":"Performance test - Gecode vs SeaPearl","title":"Performance test - Gecode vs SeaPearl","text":"The objective is to compare the execution time between SeaPearl and a commercial CP Solver.","category":"page"},{"location":"CP/performance_test/","page":"Performance test - Gecode vs SeaPearl","title":"Performance test - Gecode vs SeaPearl","text":"We expect SeaPearl to be less efficient for 2 reasons:","category":"page"},{"location":"CP/performance_test/","page":"Performance test - Gecode vs SeaPearl","title":"Performance test - Gecode vs SeaPearl","text":"Information is collected on each node in order to do further analysis (RL).\nSome constraints algorithms are not state-of-the-art algorithms.","category":"page"},{"location":"CP/performance_test/#Method","page":"Performance test - Gecode vs SeaPearl","title":"Method","text":"","category":"section"},{"location":"CP/performance_test/","page":"Performance test - Gecode vs SeaPearl","title":"Performance test - Gecode vs SeaPearl","text":"The commercial CP solver used is Gecode and the model has been implemented using MiniZinc.  The problem used for the experience is the Kidney Exchange Problem (KEP) using 7 instances from size 5 to 35 (step size of 5).  A basic model has been implemented in MiniZinc and SeaPearl using the same logic (variables, constraints, heuristics...).","category":"page"},{"location":"CP/performance_test/#Results-and-conclusions","page":"Performance test - Gecode vs SeaPearl","title":"Results and conclusions","text":"","category":"section"},{"location":"CP/performance_test/","page":"Performance test - Gecode vs SeaPearl","title":"Performance test - Gecode vs SeaPearl","text":"The main observations from the experience are:","category":"page"},{"location":"CP/performance_test/","page":"Performance test - Gecode vs SeaPearl","title":"Performance test - Gecode vs SeaPearl","text":"The time of execution grows over-polynomially with the size of the instance. This result was expected for this combinatorial problem.\nFor instances with significant time of execution (more than 1 second), Gecode is on average 7.5 times faster than SeaPearl.","category":"page"},{"location":"CP/performance_test/#PS:-Tips-to-do-a-performance-test-with-SeaPearl","page":"Performance test - Gecode vs SeaPearl","title":"PS: Tips to do a performance test with SeaPearl","text":"","category":"section"},{"location":"CP/performance_test/","page":"Performance test - Gecode vs SeaPearl","title":"Performance test - Gecode vs SeaPearl","text":"Some tips to implement a model in MiniZinc and SeaPearl with similar behavior:","category":"page"},{"location":"CP/performance_test/","page":"Performance test - Gecode vs SeaPearl","title":"Performance test - Gecode vs SeaPearl","text":"In MiniZinc use these arguments for the search: first_fail, indomain_max, complete.\nIn SeaPearl use these arguments for the search: MinDomainVariableSelection, BasicHeuristic, DFSearch (by default).\nfirst_fail and MinDomainVariableSelection do not have the same behavior in the tie (many variables having the domain with the same minimum size). first_fail uses the input order for tie-breaker. Therefore, one option is to change MinDomainVariableSelection to have the same behavior (e.g. use a counter for the id of the variables and add a lexicographical tie-breaker in MinDomainVariableSelection).\nCheck the number of explored nodes in both models. One should have similar values for each instance. One can check this information in SeaPearl thanks to model.statistics.numberOfNodes and in MiniZinc by checking the output solving statistics checkbox in the configuration editor menu.","category":"page"},{"location":"CP/constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"CP/constraints/","page":"Constraints","title":"Constraints","text":"SeaPearl.Absolute","category":"page"},{"location":"CP/constraints/#SeaPearl.Absolute","page":"Constraints","title":"SeaPearl.Absolute","text":"Absolute(x::SeaPearl.AbstractIntVar, y::SeaPearl.AbstractIntVar, ::SeaPearl.Trailer)\n\nAbsolute value constraint, enforcing y = |x|.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/","page":"Constraints","title":"Constraints","text":"SeaPearl.AllDifferent","category":"page"},{"location":"CP/constraints/#SeaPearl.AllDifferent","page":"Constraints","title":"SeaPearl.AllDifferent","text":"AllDifferent(x::Array{<:AbstractIntVar}, trailer::SeaPearl.Trailer)\n\nAllDifferent constraint, enforcing â i â  j â â¦1, length(x)â§, x[i] â  x[j].\n\nThe implementation of this contraint is inspired by:  https://www.researchgate.net/publication/200034395AFilteringAlgorithmforConstraintsofDifferencein_CSPs Many of the functions below relate to algorithms depicted in the paper, and their documentation refer to parts of the overall algorithm.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/","page":"Constraints","title":"Constraints","text":"SeaPearl.BinaryEquivalence","category":"page"},{"location":"CP/constraints/#SeaPearl.BinaryEquivalence","page":"Constraints","title":"SeaPearl.BinaryEquivalence","text":"BinaryEquivalence(x::BoolVar, y::BoolVar, trailer::SeaPearl.Trailer)\n\nBinary equivalence constraint, states that x <=> y.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/","page":"Constraints","title":"Constraints","text":"SeaPearl.BinaryImplication\nSeaPearl.BinaryMaximumBC\nSeaPearl.BinaryOr\nSeaPearl.BinaryXor\nSeaPearl.TableConstraint\nSeaPearl.BinaryImplication\nSeaPearl.Disjunctive\nSeaPearl.Element1D\nSeaPearl.Element2D\nSeaPearl.EqualConstant\nSeaPearl.GreaterOrEqualConstant\nSeaPearl.InSet\nSeaPearl.IntervalConstant\nSeaPearl.isBinaryAnd\nSeaPearl.isBinaryOr\nSeaPearl.isBinaryXor\nSeaPearl.isLessOrEqual\nSeaPearl.LessOrEqualConstant\nSeaPearl.LessOrEqual\nSeaPearl.MaximumConstraint\nSeaPearl.NotEqualConstant\nSeaPearl.NotEqual\nSeaPearl.ReifiedInSet\nSeaPearl.SetDiffSingleton\nSeaPearl.SetEqualConstant\nSeaPearl.SumGreaterThan\nSeaPearl.SumLessThan\nSeaPearl.SumToZero","category":"page"},{"location":"CP/constraints/#SeaPearl.BinaryImplication","page":"Constraints","title":"SeaPearl.BinaryImplication","text":"BinaryImplication(x::BoolVar, y::BoolVar, trailer::SeaPearl.Trailer)\n\nBinary implication constraint, states that x => y.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.BinaryMaximumBC","page":"Constraints","title":"SeaPearl.BinaryMaximumBC","text":"BinaryMaximum(x::AbstractIntVar, y::AbstractIntVar, z::AbstractIntVar, trailer::SeaPearl.Trailer)\n\nBinaryMaximum constraint, states that x == max(y, z)\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.BinaryOr","page":"Constraints","title":"SeaPearl.BinaryOr","text":"BinaryOr(x::BoolVar, y::BoolVar, trailer::SeaPearl.Trailer)\n\nBinary Or constraint, states that x || y.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.BinaryXor","page":"Constraints","title":"SeaPearl.BinaryXor","text":"BinaryXor(x::AbstractBoolVar, y::AbstractBoolVar, trailer::SeaPearl.Trailer)\n\nBinary Xor constraint, states that x â» y.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.TableConstraint","page":"Constraints","title":"SeaPearl.TableConstraint","text":"TableConstraint\n\nEfficient implentation of the constraint enforcing: â j â â¦1,mâ§, such that â i â â¦1,nâ§ xáµ¢=table[i,j].\n\nThe datastructure and the functions using it are inspired by: Demeulenaere J. et al. (2016) Compact-Table: Efficiently Filtering Table Constraints with Reversible Sparse Bit-Sets. In: Rueher M. (eds) Principles and Practice of Constraint Programming. CP 2016. Lecture Notes in Computer Science, vol 9892. Springer, Cham. https://doi.org/10.1007/978-3-319-44953-1_14\n\nTableConstraint(scope, active, table, currentTable, modifiedVariables, unfixedVariables, supports, residues)\n\nTableConstraint default constructor.\n\nArguments\n\nscope::Vector{<:AbstractIntVar}: the ordered variables present in the table.\ntable::Matrix{Int}: the original table describing the constraint (impossible assignment are filtered).\ncurrentTable::RSparseBitSet{UInt64}: the reversible representation of the table.\nmodifiedVariables::Vector{Int}: vector with the indexes of the variables modified since the last propagation.\nunfixedVariables::Vector{Int}: vector with the indexes of the variables which are not binding.\nsupports::Dict{Pair{Int,Int},BitVector}: dictionnary which, for each pair (variable => value), gives the support of this pair.\nresidues::Dict{Pair{Int,Int},Int}: dictionnary which, for each pair (variable => value), gives the residue of this pair.\n\nTableConstraint(variables, table, supports, trailer)\n\nCreate a CompactTable constraint from the variables, with values given in table and supports given in supports.\n\nThis constructor gives full control on both table and supports. The attributes are not duplicated and remains linked to the variables given to the constructor. It should be used only to avoid duplication of table when using the same table constraint many times with different variables. WARNING: all variables must have the same domain; table and supports must be cleaned.\n\nArguments\n\nvariables::Vector{<:AbstractIntVar}: vector of variables of size (n, ).\ntable::Matrix{Int}: matrix of the constraint of size (n, m).\nsupports::Dict{Pair{Int,Int},BitVector}: for each assignment, a list of the tuples supporting this assignment.\ntrailer::Trailer: the trailer of the model.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.Disjunctive","page":"Constraints","title":"SeaPearl.Disjunctive","text":"Disjunctive(earliestStartingTime::Array{<:AbstractIntVar},  processingTime::Array{Int}, trailer, filteringAlgorithm::Array{filteringAlgorithmTypes} = [algoTimeTabling])::Disjunctive\n\nConstraint that insure that no task are executed in the same time range.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.Element2D","page":"Constraints","title":"SeaPearl.Element2D","text":"Element2D(matrix::Array{Int, 2}, x::AbstractIntVar, y::AbstractIntVar, z::AbstractIntVar, SeaPearl.trailer)\n\nElement2D constraint, states that matrix[x, y] == z\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.EqualConstant","page":"Constraints","title":"SeaPearl.EqualConstant","text":"EqualConstant(x::SeaPearl.AbstractIntVar, v::Int, SeaPearl.trailer)\n\nEquality constraint, putting a constant value v for the variable x i.e. x == v.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.GreaterOrEqualConstant","page":"Constraints","title":"SeaPearl.GreaterOrEqualConstant","text":"GreaterOrEqualConstant(x::SeaPearl.AbstractIntVar, v::Int)\n\nInequality constraint, x >= v\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.InSet","page":"Constraints","title":"SeaPearl.InSet","text":"InSet(x::AbstractIntVar, s::IntSetVar, trailer::SeaPearl.Trailer)\n\nInSet constraint, states that x â s\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.IntervalConstant","page":"Constraints","title":"SeaPearl.IntervalConstant","text":"IntervalConstant(x::SeaPearl.IntVar, lower::Int, upper::Int, trailer::SeaPearl.Trailer)\n\nInequality constraint, lower <= x <= upper\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.isBinaryAnd","page":"Constraints","title":"SeaPearl.isBinaryAnd","text":"isBinaryAnd(b::AbstractBoolVar, x::AbstractBoolVar, y::AbstractBoolVar, trailer::SeaPearl.Trailer)\n\nIs And constraint, states that b <=> x and y.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.isBinaryOr","page":"Constraints","title":"SeaPearl.isBinaryOr","text":"isBinaryOr(b::AbstractBoolVar, x::AbstractBoolVar, y::AbstractBoolVar, trailer::SeaPearl.Trailer)\n\nIs Or constraint, states that b <=> x or y.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.isBinaryXor","page":"Constraints","title":"SeaPearl.isBinaryXor","text":"isBinaryXor(b::AbstractBoolVar, x::AbstractBoolVar, y::AbstractBoolVar, trailer::SeaPearl.Trailer)\n\nIs Xor constraint, states that b <=> x â» y.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.isLessOrEqual","page":"Constraints","title":"SeaPearl.isLessOrEqual","text":"isLessOrEqual(b::AbstractBoolVar, x::AbstractIntVar, y::AbstractIntVar, trailer::SeaPearl.Trailer)\n\nEquivalence between a boolean variable and the inequality between variables, states that b âº x â¤ y\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.LessOrEqualConstant","page":"Constraints","title":"SeaPearl.LessOrEqualConstant","text":"LessOrEqualConstant(x::SeaPearl.AbstractIntVar, v::Int, trailer::SeaPearl.Trailer)\n\nInequality constraint, x <= v\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.MaximumConstraint","page":"Constraints","title":"SeaPearl.MaximumConstraint","text":"MaximumConstraint(x::Array{<:AbstractIntVar},y::AbstractIntVar, trailer::SeaPearl.Trailer) <: Constraint\n\nMaximum constraint, states that y = max(x)\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.NotEqualConstant","page":"Constraints","title":"SeaPearl.NotEqualConstant","text":"NotEqualConstant(x::SeaPearl.IntVar, v::Int)\n\nInequality constraint, x != v\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.NotEqual","page":"Constraints","title":"SeaPearl.NotEqual","text":"NotEqual(x::SeaPearl.IntVar, y::SeaPearl.IntVar)\n\nInequality constraint between two variables, stating that x != y.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.ReifiedInSet","page":"Constraints","title":"SeaPearl.ReifiedInSet","text":"ReifiedInSet(x::AbstractIntVar, s::IntSetVar, b::BoolVar, trailer::Trailer)\n\nReifiedInSet contrainst, states that b âº x â s\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.SetDiffSingleton","page":"Constraints","title":"SeaPearl.SetDiffSingleton","text":"SetDiffSingleton(a::IntSetVar, b::IntSetVar, x::AbstractIntVar, trailer::Trailer)\n\nSetDiffSingleton constraint, states that a = b - {x}\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.SetEqualConstant","page":"Constraints","title":"SeaPearl.SetEqualConstant","text":"SetEqualConstant(s::IntSetVar, c::Set{Int}, trailer::Trailer)\n\nSetEqualConstant constraint, states that s == c\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.SumGreaterThan","page":"Constraints","title":"SeaPearl.SumGreaterThan","text":"SumGreaterThan(x<:AbstractIntVar, v::Int)\n\nSumming constraint, states that x[1] + x[2] + ... + x[length(x)] >= lower\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.SumLessThan","page":"Constraints","title":"SeaPearl.SumLessThan","text":"SumLessThan(x<:AbstractIntVar, v::Int)\n\nSumming constraint, states that x[1] + x[2] + ... + x[length(x)] <= v\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.SumToZero","page":"Constraints","title":"SeaPearl.SumToZero","text":"SumToZero(x<:AbstractIntVar, v::Int)\n\nSumming constraint, states that x[1] + x[2] + ... + x[length(x)] == 0\n\n\n\n\n\n","category":"type"},{"location":"#SeaPearl:-A-Julia-hybrid-CP-solver-enhanced-by-Reinforcement-Learning-techniques","page":"Home","title":"SeaPearl: A Julia hybrid CP solver enhanced by Reinforcement Learning techniques","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SeaPearl was created as a way for researchers to have a constraint programming solver that can integrate seamlessly with Reinforcement Learning technologies, using them as heuristics for value selection during branching.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The paper accompanying this solver can be found on the arXiv. If you use SeaPearl in your research, please cite our work.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Julia language was chosen for this project as we believe it is one of the few languages that can be used for Constraint Programming as well as Machine/Deep Learning.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The constraint programming part, whose architecture is heavily inspired from Mini-CP framework, is focused on readability. The code was meant to be clear and modulable so that researchers could easily get access to CP data and use it as input for their ML model.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SeaPearl comes with a set of examples that can be found in the SeaPearlZoo repository.","category":"page"}]
}
