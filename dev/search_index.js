var documenterSearchIndex = {"docs":
[{"location":"models/basics/#Building-a-model:-the-basics","page":"Basics","title":"Building a model: the basics","text":"","category":"section"},{"location":"models/basics/","page":"Basics","title":"Basics","text":"Using JuMP, you can create a really simple model.","category":"page"},{"location":"CP/performance_test/#Performance-test-Gecode-vs-SeaPearl","page":"Performance test - Gecode vs SeaPearl","title":"Performance test - Gecode vs SeaPearl","text":"","category":"section"},{"location":"CP/performance_test/","page":"Performance test - Gecode vs SeaPearl","title":"Performance test - Gecode vs SeaPearl","text":"The objective is to compare the execution time between SeaPearl and a commercial CP Solver.","category":"page"},{"location":"CP/performance_test/","page":"Performance test - Gecode vs SeaPearl","title":"Performance test - Gecode vs SeaPearl","text":"We expect SeaPearl to be less efficient for 2 reasons:","category":"page"},{"location":"CP/performance_test/","page":"Performance test - Gecode vs SeaPearl","title":"Performance test - Gecode vs SeaPearl","text":"Information is collected on each node in order to do further analysis (RL).\nSome constraints algorithms are not state-of-the-art algorithms.","category":"page"},{"location":"CP/performance_test/#Method","page":"Performance test - Gecode vs SeaPearl","title":"Method","text":"","category":"section"},{"location":"CP/performance_test/","page":"Performance test - Gecode vs SeaPearl","title":"Performance test - Gecode vs SeaPearl","text":"The commercial CP solver used is Gecode and the model has been implemented using MiniZinc.  The problem used for the experience is the Kidney Exchange Problem (KEP) using 7 instances from size 5 to 35 (step size of 5).  A basic model has been implemented in MiniZinc and SeaPearl using the same logic (variables, constraints, heuristics...).","category":"page"},{"location":"CP/performance_test/#Results-and-conclusions","page":"Performance test - Gecode vs SeaPearl","title":"Results and conclusions","text":"","category":"section"},{"location":"CP/performance_test/","page":"Performance test - Gecode vs SeaPearl","title":"Performance test - Gecode vs SeaPearl","text":"The main observations from the experience are:","category":"page"},{"location":"CP/performance_test/","page":"Performance test - Gecode vs SeaPearl","title":"Performance test - Gecode vs SeaPearl","text":"The time of execution grows over-polynomially with the size of the instance. This result was expected for this combinatorial problem.\nFor instances with significant time of execution (more than 1 second), Gecode is on average 7.5 times faster than SeaPearl.","category":"page"},{"location":"CP/performance_test/#PS:-Tips-to-do-a-performance-test-with-SeaPearl","page":"Performance test - Gecode vs SeaPearl","title":"PS: Tips to do a performance test with SeaPearl","text":"","category":"section"},{"location":"CP/performance_test/","page":"Performance test - Gecode vs SeaPearl","title":"Performance test - Gecode vs SeaPearl","text":"Some tips to implement a model in MiniZinc and SeaPearl with similar behavior:","category":"page"},{"location":"CP/performance_test/","page":"Performance test - Gecode vs SeaPearl","title":"Performance test - Gecode vs SeaPearl","text":"In MiniZinc use these arguments for the search: first_fail, indomain_max, complete.\nIn SeaPearl use these arguments for the search: MinDomainVariableSelection, BasicHeuristic, DFSearch (by default).\nfirst_fail and MinDomainVariableSelection do not have the same behavior in the tie (many variables having the domain with the same minimum size). first_fail uses the input order for tie-breaker. Therefore, one option is to change MinDomainVariableSelection to have the same behavior (e.g. use a counter for the id of the variables and add a lexicographical tie-breaker in MinDomainVariableSelection).\nCheck the number of explored nodes in both models. One should have similar values for each instance. One can check this information in SeaPearl thanks to model.statistics.numberOfNodes and in MiniZinc by checking the output solving statistics checkbox in the configuration editor menu.","category":"page"},{"location":"CP/constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"CP/constraints/","page":"Constraints","title":"Constraints","text":"SeaPearl.Absolute","category":"page"},{"location":"CP/constraints/#SeaPearl.Absolute","page":"Constraints","title":"SeaPearl.Absolute","text":"Absolute(x::SeaPearl.AbstractIntVar, y::SeaPearl.AbstractIntVar, ::SeaPearl.Trailer)\n\nAbsolute value constraint, enforcing y = |x|.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/","page":"Constraints","title":"Constraints","text":"SeaPearl.AllDifferent","category":"page"},{"location":"CP/constraints/#SeaPearl.AllDifferent","page":"Constraints","title":"SeaPearl.AllDifferent","text":"AllDifferent(x::Array{<:AbstractIntVar}, trailer::SeaPearl.Trailer)\n\nAllDifferent constraint, enforcing ∀ i ≠ j ∈ ⟦1, length(x)⟧, x[i] ≠ x[j].\n\nThe implementation of this contraint is inspired by:  https://www.researchgate.net/publication/200034395AFilteringAlgorithmforConstraintsofDifferencein_CSPs Many of the functions below relate to algorithms depicted in the paper, and their documentation refer to parts of the overall algorithm.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/","page":"Constraints","title":"Constraints","text":"SeaPearl.BinaryEquivalence","category":"page"},{"location":"CP/constraints/#SeaPearl.BinaryEquivalence","page":"Constraints","title":"SeaPearl.BinaryEquivalence","text":"BinaryEquivalence(x::BoolVar, y::BoolVar, trailer::SeaPearl.Trailer)\n\nBinary equivalence constraint, states that x <=> y.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/","page":"Constraints","title":"Constraints","text":"SeaPearl.BinaryImplication\nSeaPearl.BinaryMaximumBC\nSeaPearl.BinaryOr\nSeaPearl.BinaryXor\nSeaPearl.TableConstraint\nSeaPearl.BinaryImplication\nSeaPearl.Disjunctive\nSeaPearl.Element1D\nSeaPearl.Element2D\nSeaPearl.EqualConstant\nSeaPearl.GreaterOrEqualConstant\nSeaPearl.InSet\nSeaPearl.IntervalConstant\nSeaPearl.isBinaryAnd\nSeaPearl.isBinaryOr\nSeaPearl.isBinaryXor\nSeaPearl.isLessOrEqual\nSeaPearl.LessOrEqualConstant\nSeaPearl.LessOrEqual\nSeaPearl.MaximumConstraint\nSeaPearl.NotEqualConstant\nSeaPearl.NotEqual\nSeaPearl.ReifiedInSet\nSeaPearl.SetDiffSingleton\nSeaPearl.SetEqualConstant\nSeaPearl.SumGreaterThan\nSeaPearl.SumLessThan\nSeaPearl.SumToZero","category":"page"},{"location":"CP/constraints/#SeaPearl.BinaryImplication","page":"Constraints","title":"SeaPearl.BinaryImplication","text":"BinaryImplication(x::BoolVar, y::BoolVar, trailer::SeaPearl.Trailer)\n\nBinary implication constraint, states that x => y.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.BinaryMaximumBC","page":"Constraints","title":"SeaPearl.BinaryMaximumBC","text":"BinaryMaximum(x::AbstractIntVar, y::AbstractIntVar, z::AbstractIntVar, trailer::SeaPearl.Trailer)\n\nBinaryMaximum constraint, states that x == max(y, z)\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.BinaryOr","page":"Constraints","title":"SeaPearl.BinaryOr","text":"BinaryOr(x::BoolVar, y::BoolVar, trailer::SeaPearl.Trailer)\n\nBinary Or constraint, states that x || y.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.BinaryXor","page":"Constraints","title":"SeaPearl.BinaryXor","text":"BinaryXor(x::AbstractBoolVar, y::AbstractBoolVar, trailer::SeaPearl.Trailer)\n\nBinary Xor constraint, states that x ⊻ y.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.TableConstraint","page":"Constraints","title":"SeaPearl.TableConstraint","text":"TableConstraint\n\nEfficient implentation of the constraint enforcing: ∃ j ∈ ⟦1,m⟧, such that ∀ i ∈ ⟦1,n⟧ xᵢ=table[i,j].\n\nThe datastructure and the functions using it are inspired by: Demeulenaere J. et al. (2016) Compact-Table: Efficiently Filtering Table Constraints with Reversible Sparse Bit-Sets. In: Rueher M. (eds) Principles and Practice of Constraint Programming. CP 2016. Lecture Notes in Computer Science, vol 9892. Springer, Cham. https://doi.org/10.1007/978-3-319-44953-1_14\n\nTableConstraint(scope, active, table, currentTable, modifiedVariables, unfixedVariables, supports, residues)\n\nTableConstraint default constructor.\n\nArguments\n\nscope::Vector{<:AbstractIntVar}: the ordered variables present in the table.\ntable::Matrix{Int}: the original table describing the constraint (impossible assignment are filtered).\ncurrentTable::RSparseBitSet{UInt64}: the reversible representation of the table.\nmodifiedVariables::Vector{Int}: vector with the indexes of the variables modified since the last propagation.\nunfixedVariables::Vector{Int}: vector with the indexes of the variables which are not binding.\nsupports::Dict{Pair{Int,Int},BitVector}: dictionnary which, for each pair (variable => value), gives the support of this pair.\nresidues::Dict{Pair{Int,Int},Int}: dictionnary which, for each pair (variable => value), gives the residue of this pair.\n\nTableConstraint(variables, table, supports, trailer)\n\nCreate a CompactTable constraint from the variables, with values given in table and supports given in supports.\n\nThis constructor gives full control on both table and supports. The attributes are not duplicated and remains linked to the variables given to the constructor. It should be used only to avoid duplication of table when using the same table constraint many times with different variables. WARNING: all variables must have the same domain; table and supports must be cleaned.\n\nArguments\n\nvariables::Vector{<:AbstractIntVar}: vector of variables of size (n, ).\ntable::Matrix{Int}: matrix of the constraint of size (n, m).\nsupports::Dict{Pair{Int,Int},BitVector}: for each assignment, a list of the tuples supporting this assignment.\ntrailer::Trailer: the trailer of the model.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.Disjunctive","page":"Constraints","title":"SeaPearl.Disjunctive","text":"Disjunctive(earliestStartingTime::Array{<:AbstractIntVar},  processingTime::Array{Int}, trailer, filteringAlgorithm::Array{filteringAlgorithmTypes} = [algoTimeTabling])::Disjunctive\n\nConstraint that insure that no task are executed in the same time range.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.Element2D","page":"Constraints","title":"SeaPearl.Element2D","text":"Element2D(matrix::Array{Int, 2}, x::AbstractIntVar, y::AbstractIntVar, z::AbstractIntVar, SeaPearl.trailer)\n\nElement2D constraint, states that matrix[x, y] == z\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.EqualConstant","page":"Constraints","title":"SeaPearl.EqualConstant","text":"EqualConstant(x::SeaPearl.AbstractIntVar, v::Int, SeaPearl.trailer)\n\nEquality constraint, putting a constant value v for the variable x i.e. x == v.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.GreaterOrEqualConstant","page":"Constraints","title":"SeaPearl.GreaterOrEqualConstant","text":"GreaterOrEqualConstant(x::SeaPearl.AbstractIntVar, v::Int)\n\nInequality constraint, x >= v\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.InSet","page":"Constraints","title":"SeaPearl.InSet","text":"InSet(x::AbstractIntVar, s::IntSetVar, trailer::SeaPearl.Trailer)\n\nInSet constraint, states that x ∈ s\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.IntervalConstant","page":"Constraints","title":"SeaPearl.IntervalConstant","text":"IntervalConstant(x::SeaPearl.IntVar, lower::Int, upper::Int, trailer::SeaPearl.Trailer)\n\nInequality constraint, lower <= x <= upper\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.isBinaryAnd","page":"Constraints","title":"SeaPearl.isBinaryAnd","text":"isBinaryAnd(b::AbstractBoolVar, x::AbstractBoolVar, y::AbstractBoolVar, trailer::SeaPearl.Trailer)\n\nIs And constraint, states that b <=> x and y.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.isBinaryOr","page":"Constraints","title":"SeaPearl.isBinaryOr","text":"isBinaryOr(b::AbstractBoolVar, x::AbstractBoolVar, y::AbstractBoolVar, trailer::SeaPearl.Trailer)\n\nIs Or constraint, states that b <=> x or y.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.isBinaryXor","page":"Constraints","title":"SeaPearl.isBinaryXor","text":"isBinaryXor(b::AbstractBoolVar, x::AbstractBoolVar, y::AbstractBoolVar, trailer::SeaPearl.Trailer)\n\nIs Xor constraint, states that b <=> x ⊻ y.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.isLessOrEqual","page":"Constraints","title":"SeaPearl.isLessOrEqual","text":"isLessOrEqual(b::AbstractBoolVar, x::AbstractIntVar, y::AbstractIntVar, trailer::SeaPearl.Trailer)\n\nEquivalence between a boolean variable and the inequality between variables, states that b ⟺ x ≤ y\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.LessOrEqualConstant","page":"Constraints","title":"SeaPearl.LessOrEqualConstant","text":"LessOrEqualConstant(x::SeaPearl.AbstractIntVar, v::Int, trailer::SeaPearl.Trailer)\n\nInequality constraint, x <= v\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.MaximumConstraint","page":"Constraints","title":"SeaPearl.MaximumConstraint","text":"MaximumConstraint(x::Array{<:AbstractIntVar},y::AbstractIntVar, trailer::SeaPearl.Trailer) <: Constraint\n\nMaximum constraint, states that y = max(x)\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.NotEqualConstant","page":"Constraints","title":"SeaPearl.NotEqualConstant","text":"NotEqualConstant(x::SeaPearl.IntVar, v::Int)\n\nInequality constraint, x != v\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.NotEqual","page":"Constraints","title":"SeaPearl.NotEqual","text":"NotEqual(x::SeaPearl.IntVar, y::SeaPearl.IntVar)\n\nInequality constraint between two variables, stating that x != y.\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.ReifiedInSet","page":"Constraints","title":"SeaPearl.ReifiedInSet","text":"ReifiedInSet(x::AbstractIntVar, s::IntSetVar, b::BoolVar, trailer::Trailer)\n\nReifiedInSet contrainst, states that b ⟺ x ∈ s\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.SetDiffSingleton","page":"Constraints","title":"SeaPearl.SetDiffSingleton","text":"SetDiffSingleton(a::IntSetVar, b::IntSetVar, x::AbstractIntVar, trailer::Trailer)\n\nSetDiffSingleton constraint, states that a = b - {x}\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.SetEqualConstant","page":"Constraints","title":"SeaPearl.SetEqualConstant","text":"SetEqualConstant(s::IntSetVar, c::Set{Int}, trailer::Trailer)\n\nSetEqualConstant constraint, states that s == c\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.SumGreaterThan","page":"Constraints","title":"SeaPearl.SumGreaterThan","text":"SumGreaterThan(x<:AbstractIntVar, v::Int)\n\nSumming constraint, states that x[1] + x[2] + ... + x[length(x)] >= lower\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.SumLessThan","page":"Constraints","title":"SeaPearl.SumLessThan","text":"SumLessThan(x<:AbstractIntVar, v::Int)\n\nSumming constraint, states that x[1] + x[2] + ... + x[length(x)] <= v\n\n\n\n\n\n","category":"type"},{"location":"CP/constraints/#SeaPearl.SumToZero","page":"Constraints","title":"SeaPearl.SumToZero","text":"SumToZero(x<:AbstractIntVar, v::Int)\n\nSumming constraint, states that x[1] + x[2] + ... + x[length(x)] == 0\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#Reinforcement-Learning","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"","category":"section"},{"location":"reinforcement_learning/#Neural-Networks","page":"Reinforcement Learning","title":"Neural Networks","text":"","category":"section"},{"location":"reinforcement_learning/","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"SeaPearl.CPNN\nSeaPearl.FullFeaturedCPNN\nSeaPearl.HeterogeneousCPNN\nSeaPearl.HeterogeneousFullFeaturedCPNN\nSeaPearl.HeterogeneousVariableOutputCPNN\nSeaPearl.VariableOutputCPNN","category":"page"},{"location":"reinforcement_learning/#SeaPearl.CPNN","page":"Reinforcement Learning","title":"SeaPearl.CPNN","text":"CPNN(;\n    graphChain::Flux.Chain = Flux.Chain()\n    nodeChain::Flux.Chain = Flux.Chain()\n    globalChain::Flux.Chain = Flux.Chain()\n    outputChain::Union{Flux.Dense, Flux.Chain} = Flux.Chain()\n)\n\nThis structure is here to provide a flexible way to create a nn model which respect this approach: Making modification on the graph, then extract one node feature and modify it. The CPNN pipeline uses the features of the variable branched on (variableFeatures)  and, if specified, the global features of the graph (globalFeatures). Contrary to FullFeaturedCPNN, it does not use the features of the possible values to make predictions. This pipeline is made of 4 networks:\n\ngraphChain: a graph convolutional network (GCN). It takes the original featured graph (states.fg) as an input,\nnodeChain: a fully connected neural network (FCNN). It takes the features of the variable to branch on as an input,\nglobalChain: FCNN. It takes the global features of the graph as an input,\noutputChain: FCNN. It takes the concatenation of the outputs of nodeChain and globalChain as an input.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.FullFeaturedCPNN","page":"Reinforcement Learning","title":"SeaPearl.FullFeaturedCPNN","text":"FullFeaturedCPNN(;\n    graphChain::Flux.Chain\n    nodeChain::Flux.Chain\n    globalChain::Flux.Chain\n    outputChain::Flux.Dense\n)\n\nThis structure is here to provide a flexible way to create a nn model which respect this approach: Making modification on the graph, then extract one node feature and modify it.\n\nThis pipeline is made of 4 networks:\n\ngraphChain: a graph convolutional network (GCN). It takes the original featured graph (states.fg) as an input,\nnodeChain: a fully connected neural network (FCNN). It is used both on variableFeatures and valueFeatures.\nglobalChain: FCNN. It takes the global features of the graph as an input,\noutputChain: FCNN. It takes the concatenation of the outputs of nodeChain and globalChain as an input.\n\nLike the CPNN pipeline, the FullFeaturedCPNN pipeline uses the features (variableFeatures) of the variable branched on  and, if specified, the global features of the graph (globalFeatures). But contrary to CPNN, it also uses the features (valueFeatures) of the possible values that the variable can be assigned to.\n\nFullFeaturedCPNN generates a Q-table containing the Q-value of all the values, both the possible and impossible ones.  A mask then selects the possible values.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.HeterogeneousCPNN","page":"Reinforcement Learning","title":"SeaPearl.HeterogeneousCPNN","text":"HeterogeneousCPNN(;\n    graphChain::Flux.Chain = Flux.Chain()\n    nodeChain::Flux.Chain = Flux.Chain()\n    globalChain::Flux.Chain = Flux.Chain()\n    outputChain::Union{Flux.Dense, Flux.Chain} = Flux.Chain()\n)\n\nThis structure is here to provide a flexible way to create a nn model which respect this approach: Making modification on the graph, then extract one node feature and modify it.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.HeterogeneousFullFeaturedCPNN","page":"Reinforcement Learning","title":"SeaPearl.HeterogeneousFullFeaturedCPNN","text":"HeterogeneousFullFeaturedCPNN(;\n    graphChain::Flux.Chain\n    varChain::Flux.Chain = Flux.Chain()\n    valChain::Flux.Chain = Flux.Chain()\n    globalChain::Flux.Chain\n    outputChain::Flux.Dense\n)\n\nThis structure is here to provide a flexible way to create a nn model which respect this approach: Making modification on the graph, then extract one node feature and modify it. This CPNN is designed to process HeterogeneousFeaturedGraphs.\n\nThis pipeline works in the following way : \n\nWe apply a GNN on the input featured graph.\nWe extract the contextualized-feature of the branching variable and pass it trought varChain\nWe extract the contextualized-feature of each value that is part of the variable's domain of definition and pass it trought valChain.\nWe concat the two reshaped previous results (optionnaly with a global feature) and pass it trought outputChain to generate the output Q-vector.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.HeterogeneousVariableOutputCPNN","page":"Reinforcement Learning","title":"SeaPearl.HeterogeneousVariableOutputCPNN","text":"HeterogeneousVariableOutputCPNN(;\n    graphChain::Flux.Chain\n    nodeChain::Flux.Chain\n    outputChain::Flux.Dense\n)\n\nThis structure is here to provide a flexible way to create a nn model which respect this approach: Making modification on the graph, then extract one node feature and modify it. \n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.VariableOutputCPNN","page":"Reinforcement Learning","title":"SeaPearl.VariableOutputCPNN","text":"VariableOutputCPNN(;\n    graphChain::Flux.Chain\n    nodeChain::Flux.Chain\n    outputChain::Flux.Dense\n)\n\nThis structure is here to provide a flexible way to create a nn model which respect this approach: Making modification on the graph, then extract one node feature and modify it. \n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#State-Representation","page":"Reinforcement Learning","title":"State Representation","text":"","category":"section"},{"location":"reinforcement_learning/","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"SeaPearl.DefaultStateRepresentation\nSeaPearl.DefaultTrajectoryState\nSeaPearl.BatchedDefaultTrajectoryState\nSeaPearl.HeterogeneousStateRepresentation\nSeaPearl.HeterogeneousTrajectoryState\nSeaPearl.GraphColoringStateRepresentation\nSeaPearl.MISStateRepresentation\nSeaPearl.TsptwFeaturization\nSeaPearl.TsptwStateRepresentation\nSeaPearl.AbstractTrajectoryState\nSeaPearl.TabularTrajectoryState\nSeaPearl.NonTabularTrajectoryState\nSeaPearl.AbstractStateRepresentation\nSeaPearl.AbstractFeaturization\nSeaPearl.FeaturizedStateRepresentation\nSeaPearl.trajectoryState\nSeaPearl.featurize\n","category":"page"},{"location":"reinforcement_learning/#SeaPearl.DefaultStateRepresentation","page":"Reinforcement Learning","title":"SeaPearl.DefaultStateRepresentation","text":"DefaultStateRepresentation{F, TS}\n\nThis is the default representation used by SeaPearl unless the user define his own.\n\nIt consists in a tripartite graph representation of the CP Model, with features associated with each node and an index specifying the variable that should be branched on.\n\nFields:\n\ncplayergraph: representation of the problem as a tripartite graph.\nnodeFeatures: Feature matrix of the nodes. Each column corresponds to a node.\nglobalFeatures: Feature vector of the entire graph.\nvariableIdx: Index of the variable we are currently considering.\nallValuesIdx: Index of value nodes in cplayergraph.\nvalueToPos: Dictionary mapping the value of an action to its position in the one-hot encoding of the value. \n\nThe boolean corresponds to the fact that the feature is used or not, the integer corresponds to the position of the feature in the vector.\n\nchosenFeatures: Dictionary of featurization options. The boolean corresponds to whether the feature is active or not, \n\nthe integer corresponds to the position of the feature in the vector. See below for details about the options.\n\nconstraintTypeToId: Dictionary mapping the type of a constraint to its position in the one-hot encoding of the constraint type.\n\nThe chosenFeatures dictionary specify a boolean -notifying whether the features are active or not -  and a position for the following features:\n\n\"constraint_activity\": whether or not the constraint is active for constraint nodes\n\"constraint_type\": a one-hot encoding of the constraint type for constraint nodes\n\"nbinvolvedconstraint_propagation\": the number of times the constraint has been put in the fixPoint call stack for constraint nodes.\n\"nbnotbounded_variable\": the number of non-bound variable involve in the constraint for constraint nodes\n\"variabledomainsize\": the current size of the domain of the variable for variable nodes \n\"variableinitialdomain_size\": the initial size of the domain of the variable for variable nodes\n\"variableisbound\": whether or not the variable is bound for variable nodes\n\"values_onehot\": a one-hot encoding of the value for value nodes\n\"values_raw\": the raw value of the value for value nodes\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.DefaultTrajectoryState","page":"Reinforcement Learning","title":"SeaPearl.DefaultTrajectoryState","text":"DefaultTrajectoryState\n\nThe most basic state representation, with a featured graph, the index of the variable to branch on and optionnaly a list of possible values.\n\nfg::FeaturedGraph                                   Associated tri-partite graph containing features on each node.\nvariableIdx::Int                                    Index of the node in the feature graph that represents the choosen variable. \nallValuesIdx::Union{Nothing, AbstractVector{Int}}   Indexes of the nodes in the feature graph that reprensents values\npossibleValuesIdx::Union{Nothing, Vector{Int64}}    Indexes of the nodes in the feature graph that reprensents values in the domain of definition of the variable.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.BatchedDefaultTrajectoryState","page":"Reinforcement Learning","title":"SeaPearl.BatchedDefaultTrajectoryState","text":"BatchedDefaultTrajectoryState\n\nThe batched version of the DefaultTrajectoryState.\n\nIt contains all the information that would be stored in a FeaturedGraph but reorganised to enable simultaneous  computation on a few graphs.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.HeterogeneousStateRepresentation","page":"Reinforcement Learning","title":"SeaPearl.HeterogeneousStateRepresentation","text":"HeterogeneousStateRepresentation{F, TS}\n\nSimilar to the DefaultStateRepresentation, except that the feature matrices are specific to each type of node (constraint, variable and value).\n\nIt consists in a tripartite graph representation of the CP Model, with features associated with each node and an index specifying the variable that should be branched on.\n\nFields:\n\ncplayergraph: representation of the problem as a tripartite graph.\nconstraintNodeFeatures: Feature matrix of the constraint nodes. Each column corresponds to a node.\nvariableNodeFeatures: Feature matrix of the variable nodes. Each column corresponds to a node.\nvalueNodeFeatures: Feature matrix of the value nodes. Each column corresponds to a node.\nglobalFeatures: Feature vector of the entire graph.\nvariableIdx: Index of the variable we are currently considering.\nallValuesIdx: Index of value nodes in cplayergraph.\nvalueToPos: Dictionary mapping the value of an action to its position in the one-hot encoding of the value. \n\nThe boolean corresponds to the fact that the feature is used or not, the integer corresponds to the position of the feature in the vector.\n\nchosenFeatures: Dictionary of featurization options. The boolean corresponds to whether the feature is active or not, \n\nthe integer corresponds to the position of the feature in the vector. See below for details about the options.\n\nconstraintTypeToId: Dictionary mapping the type of a constraint to its position in the one-hot encoding of the constraint type.\n\nThe chosenFeatures dictionary specify a boolean -notifying whether the features are active or not -  and a position for the following features:\n\n\"constraint_activity\": whether or not the constraint is active for constraint nodes\n\"constraint_type\": a one-hot encoding of the constraint type for constraint nodes\n\"nbinvolvedconstraint_propagation\": the number of times the constraint has been put in the fixPoint call stack for constraint nodes.\n\"nbnotbounded_variable\": the number of non-bound variable involve in the constraint for constraint nodes\n\"variabledomainsize\": the current size of the domain of the variable for variable nodes \n\"variableinitialdomain_size\": the initial size of the domain of the variable for variable nodes\n\"variableisbound\": whether or not the variable is bound for variable nodes\n\"values_onehot\": a one-hot encoding of the value for value nodes\n\"values_raw\": the raw value of the value for value nodes\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.HeterogeneousTrajectoryState","page":"Reinforcement Learning","title":"SeaPearl.HeterogeneousTrajectoryState","text":"HeterogeneousTrajectoryState\n\nThe most basic state representation, with a featured graph, the index of the variable to branch on and optionnaly a list of possible values.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.GraphColoringStateRepresentation","page":"Reinforcement Learning","title":"SeaPearl.GraphColoringStateRepresentation","text":"GraphColoringStateRepresentation{F, TS}\n\nThis is a standard graphcoloring representation using the graph of the problem with nodes having their assigned value as label.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.MISStateRepresentation","page":"Reinforcement Learning","title":"SeaPearl.MISStateRepresentation","text":"MISStateRepresentation{F, TS}\n\nThis is a standard MIS representation using the graph of the problem with nodes having their assigned value as label.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.TsptwStateRepresentation","page":"Reinforcement Learning","title":"SeaPearl.TsptwStateRepresentation","text":"TsptwStateRepresentation{F, TS}\n\nThis is the Tsptw representation used by Quentin Cappart in Combining Reinforcement Learning and Constraint Programming for Combinatorial Optimization (https://arxiv.org/pdf/2006.01610.pdf).\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.AbstractTrajectoryState","page":"Reinforcement Learning","title":"SeaPearl.AbstractTrajectoryState","text":"AbstractTrajectoryState\n\nThe TrajectoryState is a component of the AbstractStateRepresentation specifying how to store this representation in the trajectory of the RL agent for learning.\n\nIt might be necessary to implement your own when defining a new state representation or when another data formatting is necessary for learning. To implement a subtype of AbstractTrajectoryState one must provide:\n\na struct subtype of TabularTrajectoryState or NonTabularTrajectoryState depending on you usage.\na constructor with signature YourTrajectoryState(sr::YourStateRepresentation).\na function Flux.functor(::Type{YourTrajectoryState}, ts) (see Flux.functor for further information).\nan NN model taking a YourTrajectoryState instance as an input.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.TabularTrajectoryState","page":"Reinforcement Learning","title":"SeaPearl.TabularTrajectoryState","text":"TabularTrajectoryState\n\nAbstract subtype of AbstractTrajectoryState for array based representations of state.\n\nThis type isn't currently used, but it will certainly be a lot clearer if one can easily distinguish between array based representations, and more exotic ones (e.g. graphs, named tuples...).\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.NonTabularTrajectoryState","page":"Reinforcement Learning","title":"SeaPearl.NonTabularTrajectoryState","text":"NonTabularTrajectoryState\n\nAbstract subtype of AbstractTrajectoryState for non array based representations of state.\n\nThis type is th only one currently used, but it will certainly be a lot clearer if one can easily distinguish between array based representations, and more exotic ones (e.g. graphs, named tuples...).\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.AbstractStateRepresentation","page":"Reinforcement Learning","title":"SeaPearl.AbstractStateRepresentation","text":"AbstractStateRepresentation{TS}\n\nThe AbstractStateRepresentation is the abstract type of the structures representing the internal state of the CPModel and eventually the state of the search in a way that will be as expressive as possible.\n\nIt requires a specific AbstractTrajectoryState to make the bridge between the internal state representation and one the RL agent can use to decide of the value to be assigned when branching.\n\nA user can use the DefaultStateRepresentation with the DefaultTrajectoryState provided by the package but he has the possibility to define his own.\n\nTo define a new one, the user must provide:\n\na new structure, subtype of AbstractStateRepresentation with the appropriate subtype of AbstractTrajectoryState and all its dependencies.\na constructor from a CPModel, with keyword argument action_space.\na function update_representation!(::AbstractStateRepresentation, ::CPModel, ::AbstractIntVar) to update the state representation at each step.\n\nLook at the DefaultStateRepresentation to get inspired.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.AbstractFeaturization","page":"Reinforcement Learning","title":"SeaPearl.AbstractFeaturization","text":"AbstractFeaturization\n\nEvery subtype of FeaturizedStateRepresentation{F} requires an AbstractFeaturization.\n\nThis type gives the possibility to characterise these feature based representations, and thus gives the ability to easily define new ones. To implement your own featurization, one must provide:\n\na struct subtype of AbstractFeaturization (no field is used by the DefaultStateRepresentation).\na function featurize(::FeaturizedStateRepresentation{YourFeaturization, TS}) where TS returning a feature Matrix with features stored columnwise.\na function feature_length(::Type{<:FeaturizedStateRepresentation{YourFeaturization, TS} where TS} returning the size of a feature vector.\noptionally a function update_features!(::FeaturizedStateRepresentation{YourFeaturization, TS}, ::CPModel) where TS to update your feature vectors based on statistics gathered by the CP Model.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.FeaturizedStateRepresentation","page":"Reinforcement Learning","title":"SeaPearl.FeaturizedStateRepresentation","text":"FeaturizedStateRepresentation{F, TS}\n\nAbstract subtype of AbstractStateRepresentation specializing the type of features used in the representation.\n\nWhen a user wants to try a new featurization with the same organisation of the featurized elements, instead of having to completely redefine a new type of AbstractStateRepresentation, he can keep the same and just use a new AbstractFeaturization.\n\n\n\n\n\n","category":"type"},{"location":"reinforcement_learning/#SeaPearl.trajectoryState","page":"Reinforcement Learning","title":"SeaPearl.trajectoryState","text":"trajectoryState(sr::AbstractStateRepresentation{TS})\n\nReturn a TrajectoryState based on the present state represented by sr.\n\nThe type of the returned object is defined by the TS parametric type defined in sr.\n\n\n\n\n\n","category":"function"},{"location":"reinforcement_learning/#SeaPearl.featurize","page":"Reinforcement Learning","title":"SeaPearl.featurize","text":"featurize(sr::DefaultStateRepresentation{DefaultFeaturization, TS})\n\nCreate features for every node of the graph. Can be overwritten for a completely custom featurization.\n\nDefault behavior consists in a 3D One-hot vector that encodes whether the node represents a Constraint, a Variable or a Value.\n\nIt is also possible to pass a chosen_features dictionary allowing to choose among some non mandatory features.  It will be used in initChosenFeatures! to initialize sr.chosenFeatures.  See DefaultStateRepresentation for a list of possible options. It is only necessary to specify the options you wish to activate.\n\n\n\n\n\nfeaturize(sr::HeterogeneousStateRepresentation{DefaultFeaturization, TS})\n\nCreate features for every node of the graph. Can be overwritten for a completely custom featurization.\n\nDefault behavior consists in a 3D One-hot vector that encodes whether the node represents a Constraint, a Variable or a Value.\n\nIt is also possible to pass a chosen_features dictionary allowing to choose among some non mandatory features.  It will be used in initChosenFeatures! to initialize sr.chosenFeatures.  See HeterogeneousStateRepresentation for a list of possible options. It is only necessary to specify the options you wish to activate.\n\n\n\n\n\nfunction featurize(sr::TsptwStateRepresentation{TsptwFeaturization})\n\nCreate nodeFeatures for every node of the graph. Supposed to be overwritten.  Tsptw behavior is to call Tsptw_featurize.\n\n\n\n\n\nfunction featurize(sr::GraphColoringStateRepresentation{GraphColoringFeaturization})\n\nCreate nodeFeatures for every node of the graph (current color of the node or -1 if the color has not been determined yet)\n\n\n\n\n\nfunction featurize(sr::MISStateRepresentation{MISFeaturization})\n\nCreate nodeFeatures for every node of the graph (current color of the node or -1 if the color has not been determined yet)\n\n\n\n\n\n","category":"function"},{"location":"community/#Community","page":"Community","title":"Community","text":"","category":"section"},{"location":"community/","page":"Community","title":"Community","text":"Everyone is welcome to contribute to this project, by opening issues or PR on the Github repository.","category":"page"},{"location":"#SeaPearl:-A-Julia-hybrid-CP-solver-enhanced-by-Reinforcement-Learning-techniques","page":"Home","title":"SeaPearl: A Julia hybrid CP solver enhanced by Reinforcement Learning techniques","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SeaPearl was created as a way for researchers to have a constraint programming solver that can integrate seamlessly with Reinforcement Learning technologies, using them as heuristics for value selection during branching.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The paper accompanying this solver can be found on the arXiv. If you use SeaPearl in your research, please cite our work.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Julia language was chosen for this project as we believe it is one of the few languages that can be used for Constraint Programming as well as Machine/Deep Learning.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The constraint programming part, whose architecture is heavily inspired from Mini-CP framework, is focused on readability. The code was meant to be clear and modulable so that researchers could easily get access to CP data and use it as input for their ML model.","category":"page"},{"location":"","page":"Home","title":"Home","text":"SeaPearl comes with a set of examples that can be found in the SeaPearlZoo repository.","category":"page"},{"location":"CP/trailer/#Trailer:-backtrack-easily-and-efficiently","page":"Trailer","title":"Trailer: backtrack easily and efficiently","text":"","category":"section"},{"location":"CP/trailer/","page":"Trailer","title":"Trailer","text":"The trailer is the object that keeps track of anything you want to keep track of. Some objects will take a trailer as a parameter in their constructor. When it does, it means that their state can be saved and restored on demand using the functions described below.","category":"page"},{"location":"CP/trailer/#State-manipulation","page":"Trailer","title":"State manipulation","text":"","category":"section"},{"location":"CP/trailer/","page":"Trailer","title":"Trailer","text":"Those functions are used to change the current state, save and or restore it.","category":"page"},{"location":"CP/trailer/","page":"Trailer","title":"Trailer","text":"Note that during your \"state exploration\", you can only restore higher. It is not possible to restore some deeper state, or state that could be in the same level. For example, if you have a state A at some point, you call SeaPearl.saveState! to store it. You edit some SeaPearl.StateObject, making you at some state B. Then you call SeaPearl.restoreState! that will restore every SeaPearl.StateObject to the state A. At that point, there is no way to go back to the state B using the trailer.","category":"page"},{"location":"CP/trailer/","page":"Trailer","title":"Trailer","text":"SeaPearl.StateObject\r\nSeaPearl.StateEntry\r\nSeaPearl.trail!\r\nSeaPearl.setValue!\r\nSeaPearl.saveState!\r\nSeaPearl.restoreState!\r\nSeaPearl.withNewState!\r\nSeaPearl.restoreInitialState!","category":"page"},{"location":"CP/trailer/#SeaPearl.StateObject","page":"Trailer","title":"SeaPearl.StateObject","text":"StateObject{T}(value::T, trailer::Trailer)\n\nA reversible object of value value that has a type T, storing its modification into trailer.\n\n\n\n\n\n","category":"type"},{"location":"CP/trailer/#SeaPearl.StateEntry","page":"Trailer","title":"SeaPearl.StateEntry","text":"StateEntry{T}(value::T, object::StateObject{T})\n\nAn entry that can be stacked in the trailer, containing the former value of the object, and a reference to theobject` so that it can be restored by the trailer.\n\n\n\n\n\n","category":"type"},{"location":"CP/trailer/#SeaPearl.trail!","page":"Trailer","title":"SeaPearl.trail!","text":"trail!(var::StateObject{T})\n\nStore the current value of var into its trailer.\n\n\n\n\n\n","category":"function"},{"location":"CP/trailer/#SeaPearl.setValue!","page":"Trailer","title":"SeaPearl.setValue!","text":"setValue!(var::StateObject{T}, value::T) where {T}\n\nChange the value of var, replacing it with value, and if needed, store the former value into var's trailer.\n\n\n\n\n\n","category":"function"},{"location":"CP/trailer/#SeaPearl.saveState!","page":"Trailer","title":"SeaPearl.saveState!","text":"saveState!(trailer::Trailer)\n\nStore the current state into the trailer, replacing the current stack with an empty one.\n\n\n\n\n\n","category":"function"},{"location":"CP/trailer/#SeaPearl.restoreState!","page":"Trailer","title":"SeaPearl.restoreState!","text":"restoreState!(trailer::Trailer)\n\nIterate over the last state to restore every former value, used to backtrack every change  made after the last call to saveState!.\n\n\n\n\n\n","category":"function"},{"location":"CP/trailer/#SeaPearl.withNewState!","page":"Trailer","title":"SeaPearl.withNewState!","text":"withNewState!(func, trailer::Trailer)\n\nCall the func function with a new state, restoring it after. Aimed to be used with the do block syntax.\n\nExamples\n\nusing SeaPearl\ntrailer = SeaPearl.Trailer()\nreversibleInt = SeaPearl.StateObject{Int}(3, trailer)\nSeaPearl.withNewState!(trailer) do\n    SeaPearl.setValue!(reversibleInt, 5)\nend\nreversibleInt.value # 3\n\n\n\n\n\n","category":"function"},{"location":"CP/trailer/#SeaPearl.restoreInitialState!","page":"Trailer","title":"SeaPearl.restoreInitialState!","text":"restoreInitialState!(trailer::Trailer)\n\nRestore every linked object to its initial state. Basically call restoreState! until not possible.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#Variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"CP/variables/#Integer-variables","page":"Variables","title":"Integer variables","text":"","category":"section"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"The implementation of integer variables in SeaPearl is heavily inspired on MiniCP. If you have some troubles understanding how it works, you can get more visual explanations by reading their slides.","category":"page"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"The integer variables are all a subset of AbstractIntVar.","category":"page"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"Every AbstractIntVar must have a unique id that you can retrieve with id.","category":"page"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"SeaPearl.id\nSeaPearl.isbound\nSeaPearl.assign!(::SeaPearl.AbstractIntVar, ::Int)\nSeaPearl.assignedValue","category":"page"},{"location":"CP/variables/#SeaPearl.id","page":"Variables","title":"SeaPearl.id","text":"function id(x::AbstractVar)\n\nReturn the string identifier of x. Every variable must be assigned a unique identifier upon creation, that will be used as a key to identify the variable in the CPModel object.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#SeaPearl.isbound","page":"Variables","title":"SeaPearl.isbound","text":"isbound(x::AbstractIntVar)\n\nCheck whether x has an assigned value.\n\n\n\n\n\nisbound(x::AbstractBoolVar)\n\nCheck whether x has an assigned value.\n\n\n\n\n\nisbound(x::IntSetVar)\n\nCheck whether x has an assigned value (meaning its domain only contains one subset)\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#SeaPearl.assign!-Tuple{SeaPearl.AbstractIntVar, Int64}","page":"Variables","title":"SeaPearl.assign!","text":"assign!(x::AbstractIntVar, value::Int)\n\nRemove everything from the domain of x but value.\n\n\n\n\n\n","category":"method"},{"location":"CP/variables/#SeaPearl.assignedValue","page":"Variables","title":"SeaPearl.assignedValue","text":"assignedValue(x::AbstractIntVar)\n\nReturn the assigned value of x. Throw an error if x is not bound.\n\n\n\n\n\nassignedValue(x::BoolVar)\n\nReturn the assigned value of x. Throw an error if x is not bound.\n\n\n\n\n\nassignedValue(x::IntSetVar)\n\nReturn the assigned value of x, i.e. the only subset it contains. Throw an error if x is not bound.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#IntVar","page":"Variables","title":"IntVar","text":"","category":"section"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"SeaPearl.IntVar\nSeaPearl.IntVar(::Int, ::Int, ::String, ::SeaPearl.Trailer)","category":"page"},{"location":"CP/variables/#SeaPearl.IntVar","page":"Variables","title":"SeaPearl.IntVar","text":"struct IntVar <: AbstractIntVar\n\nA \"simple\" integer variable, whose domain can be any set of integers. The constraints that affect this variable are stored in the onDomainChange array.\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#SeaPearl.IntVar-Tuple{Int64, Int64, String, SeaPearl.Trailer}","page":"Variables","title":"SeaPearl.IntVar","text":"function IntVar(min::Int, max::Int, id::String, trailer::Trailer)\n\nCreate an IntVar with a domain being the integer range [min, max] with the id string identifier and that will be backtracked by trailer.\n\n\n\n\n\n","category":"method"},{"location":"CP/variables/#IntDomain","page":"Variables","title":"IntDomain","text":"","category":"section"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"SeaPearl.AbstractIntDomain\nSeaPearl.IntDomain\nSeaPearl.IntDomain(::SeaPearl.Trailer, ::Int, ::Int)","category":"page"},{"location":"CP/variables/#SeaPearl.AbstractIntDomain","page":"Variables","title":"SeaPearl.AbstractIntDomain","text":"abstract type AbstractIntDomain end\n\nAbstract domain type. Every integer domain must inherit from this type.\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#SeaPearl.IntDomain","page":"Variables","title":"SeaPearl.IntDomain","text":"struct IntDomain <: AbstractIntDomain\n\nSparse integer domain. Can contain any set of integer.\n\nYou must note that this implementation takes as much space as the size of the initial domain. However, it can be pretty efficient in accessing and editing. Operation costs are detailed for each method.\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#SeaPearl.IntDomain-Tuple{SeaPearl.Trailer, Int64, Int64}","page":"Variables","title":"SeaPearl.IntDomain","text":"IntDomain(trailer::Trailer, n::Int, offset::Int)\n\nCreate an integer domain going from ofs + 1 to ofs + n. Will be backtracked by the given trailer.\n\n\n\n\n\n","category":"method"},{"location":"CP/variables/#Domain-updates","page":"Variables","title":"Domain updates","text":"","category":"section"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"SeaPearl.isempty\nSeaPearl.length\nSeaPearl.isempty\nBase.in(::Int, ::SeaPearl.IntDomain)\nSeaPearl.remove!\nSeaPearl.removeAll!\nSeaPearl.removeAbove!\nSeaPearl.removeBelow!\nSeaPearl.assign!\nBase.iterate(::SeaPearl.IntDomain)\nSeaPearl.updateMaxFromRemovedVal!\nSeaPearl.updateMinFromRemovedVal!\nSeaPearl.updateBoundsFromRemovedVal!\nSeaPearl.minimum\nSeaPearl.maximum","category":"page"},{"location":"CP/variables/#Base.isempty","page":"Variables","title":"Base.isempty","text":"isempty(dom::IntDomain)\n\nReturn true iff dom is an empty set. Done in constant time.\n\n\n\n\n\nisempty(dom::BoolDomain)\n\nReturn true iff dom is an empty set. Done in constant time.\n\n\n\n\n\nisempty(dom::IntDomainView)\n\nReturn true iff dom is an empty set.\n\n\n\n\n\nisempty(dom::BoolDomainView)\n\nReturn true iff dom is an empty set.\n\n\n\n\n\nBase.isempty(model::CPModel)::Bool\n\nReturn a boolean describing if the model is empty or not.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#Base.length","page":"Variables","title":"Base.length","text":"length(dom::IntDomain)\n\nReturn the size of dom. Done in constant time.\n\n\n\n\n\nlength(dom::BoolDomain)\n\nReturn the size of dom. Done in constant time.\n\n\n\n\n\nlength(dom::IntDomainView)\n\nReturn the size of dom.\n\n\n\n\n\nlength(dom::BoolDomainView)\n\nReturn the size of dom.\n\n\n\n\n\nlength(dom::IntDomain)\n\nReturn the size of dom. Done in constant time.\n\n\n\n\n\nBase.length(set::SetModification)\n\na generic function length is needed for all modifications. \n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#Base.in-Tuple{Int64, SeaPearl.IntDomain}","page":"Variables","title":"Base.in","text":"Base.in(value::Int, dom::IntDomain)\n\nCheck if an integer is in the domain. Done in constant time.\n\n\n\n\n\n","category":"method"},{"location":"CP/variables/#SeaPearl.remove!","page":"Variables","title":"SeaPearl.remove!","text":"remove!(dom::IntDomain, value::Int)\n\nRemove value from dom. Done in constant time.\n\n\n\n\n\nremove!(dom::BoolDomain, value::Bool)\n\nRemove value from dom. Done in constant time.\n\n\n\n\n\nremove!(dom::BoolDomain, value::Int)\n\nRemove value from dom. Done in constant time.\n\n\n\n\n\nremove!(dom::IntDomainView, value::Int)\n\nRemove value from dom.\n\n\n\n\n\nremove!(dom::BoolDomainViewNot, value::Bool)\n\nRemove value from dom.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#SeaPearl.removeAll!","page":"Variables","title":"SeaPearl.removeAll!","text":"removeAll!(dom::IntDomain)\n\nRemove every value from dom. Return the removed values. Done in constant time.\n\n\n\n\n\nremoveAll!(dom::BoolDomain)\n\nRemove every value from dom. Return the removed values. Done in constant time.\n\n\n\n\n\nremoveAll!(dom::IntDomainView)\n\nRemove every value from dom. Return the removed values.\n\n\n\n\n\nremoveAll!(dom::BoolDomainViewNot)\n\nRemove every value from dom. Return the removed values.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#SeaPearl.removeAbove!","page":"Variables","title":"SeaPearl.removeAbove!","text":"removeAbove!(dom::IntDomain, value::Int)\n\nRemove every integer of dom that is strictly above value. Done in linear time.\n\n\n\n\n\nremoveAbove!(dom::IntDomain, value::Int)\n\nRemove every integer of dom that is strictly above value. Done in linear time.\n\n\n\n\n\nremoveAbove!(dom::IntDomainView, value::Int)\n\nRemove every integer of dom that is strictly above value.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#SeaPearl.removeBelow!","page":"Variables","title":"SeaPearl.removeBelow!","text":"removeBelow!(dom::IntDomain, value::Int)\n\nRemove every integer of dom that is strictly below value. Return the pruned values. Done in linear time.\n\n\n\n\n\nremoveBelow!(dom::IntDomain, value::Int)\n\nRemove every integer of dom that is strictly below value. Return the pruned values. Done in linear time.\n\n\n\n\n\nremoveBelow!(dom::IntDomainView, value::Int)\n\nRemove every integer of dom that is strictly below value. Return the pruned values.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#SeaPearl.assign!","page":"Variables","title":"SeaPearl.assign!","text":"assign!(dom::IntDomain, value::Int)\n\nRemove everything from the domain but value. Return the removed values. Return the pruned values. Done in constant time.\n\n\n\n\n\nassign!(x::AbstractIntVar, value::Int)\n\nRemove everything from the domain of x but value.\n\n\n\n\n\nassign!(dom::BoolDomain, value::Bool)\n\nRemove everything from the domain but value. Return the removed values. Return the pruned values. Done in constant time.\n\n\n\n\n\nassign!(dom::BoolDomain, value::Int)\n\nRemove everything from the domain but value. Return the removed values. Return the pruned values. Done in constant time.\n\n\n\n\n\nassign!(x::BoolVar, value::Bool)\n\nRemove everything from the domain of x but value.\n\n\n\n\n\nassign!(dom::IntDomainView, value::Int)\n\nRemove everything from the domain but value. Return the removed values. Return the pruned values.\n\n\n\n\n\nassign!(dom::BoolDomainViewNot, value::Bool)\n\nRemove everything from the domain but value. Return the removed values. Return the pruned values.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#Base.iterate-Tuple{SeaPearl.IntDomain}","page":"Variables","title":"Base.iterate","text":"Base.iterate(dom::IntDomain, state=1)\n\nIterate over the domain in an efficient way. The order may not be consistent. WARNING: Do NOT update the domain you are iterating on.\n\n\n\n\n\n","category":"method"},{"location":"CP/variables/#SeaPearl.updateMaxFromRemovedVal!","page":"Variables","title":"SeaPearl.updateMaxFromRemovedVal!","text":"updateMaxFromRemovedVal!(dom::IntDomain, v::Int)\n\nKnowing that v just got removed from dom, update dom's maximum value. Done in constant time.\n\n\n\n\n\nupdateMaxFromRemovedVal!(dom::IntDomainView, v::Int)\n\nKnowing that v just got removed from dom, update dom's maximum value.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#SeaPearl.updateMinFromRemovedVal!","page":"Variables","title":"SeaPearl.updateMinFromRemovedVal!","text":"updateMinFromRemovedVal!(dom::IntDomain, v::Int)\n\nKnowing that v just got removed from dom, update dom's minimum value. Done in constant time.\n\n\n\n\n\nupdateMinFromRemovedVal!(dom::IntDomainView, v::Int)\n\nKnowing that v just got removed from dom, update dom's minimum value.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#SeaPearl.updateBoundsFromRemovedVal!","page":"Variables","title":"SeaPearl.updateBoundsFromRemovedVal!","text":"updateBoundsFromRemovedVal!(dom::AbstractIntDomain, v::Int)\n\nKnowing that v just got removed from dom, update dom's minimum and maximum value. Done in constant time.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#SeaPearl.minimum","page":"Variables","title":"SeaPearl.minimum","text":"minimum(dom::IntDomain)\n\nReturn the minimum value of dom. Done in constant time.\n\n\n\n\n\nminimum(dom::BoolDomain)\n\nReturn the minimum value of dom. Done in constant time.\n\n\n\n\n\nminimum(dom::IntDomainView)\n\nReturn the minimum value of dom.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/#SeaPearl.maximum","page":"Variables","title":"SeaPearl.maximum","text":"maximum(dom::IntDomain)\n\nReturn the maximum value of dom. Done in constant time.\n\n\n\n\n\nmaximum(dom::BoolDomain)\n\nReturn the maximum value of dom. Done in constant time.\n\n\n\n\n\nmaximum(dom::IntDomainView)\n\nReturn the maximum value of dom.\n\n\n\n\n\n","category":"function"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"If you want to express some variations of an integer variable x (for example -x or a x with a  0) in a constraint, you can use the IntVarView types:","category":"page"},{"location":"CP/variables/#IntVarView","page":"Variables","title":"IntVarView","text":"","category":"section"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"SeaPearl.IntVarViewMul\nSeaPearl.IntVarViewOpposite\nSeaPearl.IntVarViewOffset","category":"page"},{"location":"CP/variables/#SeaPearl.IntVarViewMul","page":"Variables","title":"SeaPearl.IntVarViewMul","text":"IntVarViewMul(x::AbstractIntVar, a::Int, id::String)\n\nCreate a fake variable y, such that y == a*x. This variable behaves like an usual one.\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#SeaPearl.IntVarViewOpposite","page":"Variables","title":"SeaPearl.IntVarViewOpposite","text":"IntVarViewOpposite(x::AbstractIntVar, id::String)\n\nCreate a *fake* variable `y`, such that `y = -x`. This variable behaves like an usual one.\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#IntDomainView","page":"Variables","title":"IntDomainView","text":"","category":"section"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"SeaPearl.IntDomainViewMul\nSeaPearl.IntDomainViewOpposite\nSeaPearl.IntDomainViewOffset","category":"page"},{"location":"CP/variables/#SeaPearl.IntDomainViewMul","page":"Variables","title":"SeaPearl.IntDomainViewMul","text":"IntDomainViewMul(orig::AbstractIntDomain, a::Int)\n\nDomain for an integer variable that is a multiple of another integer variable. See IntVarViewMul.\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#SeaPearl.IntDomainViewOpposite","page":"Variables","title":"SeaPearl.IntDomainViewOpposite","text":"IntDomainViewOpposite(orig::AbstractIntDomain)\n\nDomain for an integer variable that is the opposite of another integer variable (y = -x).\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#SeaPearl.IntDomainViewOffset","page":"Variables","title":"SeaPearl.IntDomainViewOffset","text":"IntDomainViewOffset(orig::AbstractIntDomain, c::Int)\n\nDomain for an integer variable that is offset by a constant 'c' (y = x + c)\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#Boolean-Variables","page":"Variables","title":"Boolean Variables","text":"","category":"section"},{"location":"CP/variables/#Base-Boolean-Variables","page":"Variables","title":"Base Boolean Variables","text":"","category":"section"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"SeaPearl.BoolVar","category":"page"},{"location":"CP/variables/#SeaPearl.BoolVar","page":"Variables","title":"SeaPearl.BoolVar","text":"struct BoolVar <: AbstractVar\n\nA \"simple\" boolean variable. The constraints that affect this variable are stored in the onDomainChange array.\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#Boolean-View-Variables","page":"Variables","title":"Boolean View Variables","text":"","category":"section"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"SeaPearl.BoolVarViewNot","category":"page"},{"location":"CP/variables/#SeaPearl.BoolVarViewNot","page":"Variables","title":"SeaPearl.BoolVarViewNot","text":"BoolVarViewNot(x::AbstractBoolVar, id::String)\n\nFake variable y, such that y = ¬x. This variable behaves like an usual one.\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#Boolean-Domains","page":"Variables","title":"Boolean Domains","text":"","category":"section"},{"location":"CP/variables/","page":"Variables","title":"Variables","text":"SeaPearl.BoolDomain\nSeaPearl.BoolDomainViewNot","category":"page"},{"location":"CP/variables/#SeaPearl.BoolDomain","page":"Variables","title":"SeaPearl.BoolDomain","text":"struct BoolDomain <: AbstractDomain\n\nBoolean domain, uses a IntDomain in it. (true is 1 and false is 0)\n\n\n\n\n\n","category":"type"},{"location":"CP/variables/#SeaPearl.BoolDomainViewNot","page":"Variables","title":"SeaPearl.BoolDomainViewNot","text":"BoolDomainViewNot <: BoolDomainView Domain for BoolVarView variables\n\n\n\n\n\n","category":"type"}]
}
